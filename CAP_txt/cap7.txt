GIT TOOLS

7.1 [[ Git Tools - Seleção de Revisão ]]

Até agora, você aprendeu a maior parte dos comandos e fluxos de trabalho diários necessários para gerenciar ou manter um repositório Git para o controle de código-fonte. Você realizou as tarefas básicas de rastreamento e confirmação de arquivos e aproveitou o poder da área de preparação e da divisão e mesclagem de tópicos leves.

Agora você explorará uma série de coisas muito poderosas que o Git pode fazer que você pode não usar necessariamente no dia-a-dia, mas que você pode precisar em algum momento.

*Seleção de Revisão
O Git permite que você especifique commits específicos ou um intervalo de commits de várias maneiras. Eles não são necessariamente óbvios, mas são úteis para saber.

(Revisões Únicas)
Você pode, obviamente, referir-se a um commit pelo hash SHA-1 que é dado, mas existem maneiras mais amigáveis ​​para os humanos de se referir aos commits também. Esta seção descreve as várias maneiras de se referir a um único commit.

(Short SHA-1)
O Git é esperto o bastante para descobrir qual commit você pretende digitar se você fornecer os primeiros caracteres, contanto que o seu SHA-1 parcial tenha pelo menos quatro caracteres de comprimento e seja inequívoco - isto é, apenas um objeto no repositório atual começa com que SHA-1 parcial.

Por exemplo, para ver uma confirmação específica, suponha que você execute um git logcomando e identifique a confirmação na qual adicionou determinada funcionalidade:

$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff
Neste caso, escolha [1c002dd....] Se você se [git show] comprometer, os seguintes comandos são equivalentes (assumindo que as versões mais curtas não sejam ambíguas):

$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d

O Git pode descobrir uma abreviação curta e única para seus valores SHA-1. Se você passar [--abbrev-commit] para o [git log] comando, a saída usará valores menores, mas os manterá exclusivos; o padrão é usar sete caracteres, mas torna-os mais longos, se necessário, para manter o SHA-1 não ambíguo:

$ git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit

Geralmente, oito a dez caracteres são mais que suficientes para serem exclusivos em um projeto.

Como exemplo, o kernel do Linux, que é um projeto muito grande com mais de 450.000 confirmações e 3,6 milhões de objetos, não possui dois objetos cujos SHA-1s se sobrepõem mais do que os primeiros 11 caracteres.



|Nota
UMA BREVE NOTA SOBRE O SHA-1
Muitas pessoas ficam preocupadas, em algum momento, que terão aleatoriamente dois objetos em seu repositório que terão o mesmo valor SHA-1. O que então?

Se acontecer de você cometer um objeto com hashes para o mesmo valor SHA-1 que um objeto anterior em seu repositório, o Git verá o objeto anterior já em seu banco de dados do Git e assumirá que ele já está escrito. Se você tentar fazer o check out desse objeto novamente em algum momento, sempre obterá os dados do primeiro objeto.

No entanto, você deve estar ciente de quão ridiculamente improvável esse cenário é. O resumo SHA-1 é de 20 bytes ou 160 bits. O número de objectos hash aleatoriamente necessários para garantir uma probabilidade de 50% de uma única colisão é de cerca de 2 80 (a fórmula para determinar a probabilidade de colisão é p = (n(n-1)/2) * (1/2^160)). 2 80 é de 1,2 x 10 24 ou 1 biliões de biliões. Isso é 1.200 vezes o número de grãos de areia na terra.

Aqui está um exemplo para você ter uma ideia do que seria necessário para obter uma colisão SHA-1. Se todos os 6,5 bilhões de humanos na Terra estivessem programando, e a cada segundo, cada um produzindo código equivalente a todo o histórico do kernel do Linux (3,6 milhões de objetos Git) e o colocando em um enorme repositório Git, levaria cerca de 2 anos até que o repositório contivesse objetos suficientes para ter 50% de probabilidade de uma única colisão de objeto SHA-1. Existe uma probabilidade maior de que todos os membros de sua equipe de programação sejam atacados e mortos por lobos em incidentes não relacionados na mesma noite.

(Referências de ramo)
A maneira mais direta de especificar um commit requer que ele tenha uma referência de ramificação apontada para ele. Em seguida, você pode usar um nome de ramificação em qualquer comando do Git que espera um objeto de confirmação ou um valor SHA-1. Por exemplo, se você deseja mostrar o último objeto de confirmação em uma ramificação, os seguintes comandos são equivalentes, supondo que a topic1ramificação aponte para ca82a6d:

$ git show ca82a6dff817ec66f44342007202690a93763949
$ git show topic1

Se você quiser ver para qual SHA-1 específico um ramo aponta, ou se você quer ver o que qualquer um desses exemplos resume em termos de SHA-1s, você pode usar uma ferramenta de encanamento chamada Git rev-parse. Você pode ver o Git Internals para mais informações sobre ferramentas de encanamento; Basicamente, rev-parseexiste para operações de nível inferior e não foi projetado para ser usado em operações do dia-a-dia. No entanto, pode ser útil, por vezes, quando você precisa ver o que realmente está acontecendo. Aqui você pode correr [rev-parse] em seu ramo.

$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949
RefLog Shortnames

Uma das coisas que o Git faz ao fundo enquanto você está trabalhando é manter um “reflog” - um registro de onde suas referências ao HEAD e ao ramo foram nos últimos meses.

Você pode ver seu reflog usando [git reflog]:

$ git reflog
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by recursive.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD

Toda vez que sua dica de filial é atualizada por qualquer motivo, o Git armazena essas informações para você neste histórico temporário. E você também pode especificar confirmações mais antigas com esses dados. Se você quiser ver o quinto valor anterior do HEAD do seu repositório, você pode usar a @{n}referência que você vê na saída do reflog:

$ git show HEAD@{5}

Você também pode usar essa sintaxe para ver onde uma ramificação estava há algum tempo. Por exemplo, para ver onde sua masterfilial estava ontem, você pode digitar

$ git show master@{yesterday}

Isso mostra onde a dica do ramo foi ontem. Essa técnica funciona apenas para dados que ainda estão no seu reflog, então você não pode usá-la para procurar por commits com mais de alguns meses.

Para ver informações reflog formatadas como a git logsaída, você pode executar git log -g:

$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon <schacon@gmail.com>)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon <schacon@gmail.com>)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

É importante observar que as informações do reflog são estritamente locais - é um registro do que você fez no seu repositório. As referências não serão as mesmas na cópia do repositório de outra pessoa; e logo depois de clonar inicialmente um repositório, você terá um reflogo vazio, já que nenhuma atividade ocorreu ainda em seu repositório. A execução git show HEAD@{2.months.ago} funcionará apenas se você clonou o projeto há pelo menos dois meses - se você clonou cinco minutos atrás, não obterá resultados.

Referências de Ancestrais
A outra maneira principal de especificar um commit é através de sua ancestralidade. Se você colocar um ^no final de uma referência, o Git o resolve como o pai desse commit. Suponha que você olhe a história do seu projeto:

$ git log --pretty=format:'%h %s' --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list
Então, você pode ver o commit anterior especificando HEAD^, que significa “o pai de HEAD”:

$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

Você também pode especificar um número após o ^- por exemplo, d921970^2 significa “o segundo pai de d921970”. Essa sintaxe é útil apenas para confirmações de mesclagem, que têm mais de um pai. O primeiro pai é o ramo em que você estava quando você mesclou, e o segundo é o commit no branch que você mesclou:

$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly <paul+git@mjr.org>
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes 

A outra especificação de ancestralidade principal é a ~. Isso também se refere ao primeiro pai, portanto, HEAD~e HEAD^são equivalentes. A diferença se torna aparente quando você especifica um número. [HEAD~2] significa "o primeiro pai do primeiro pai" ou "o avô" - ele percorre os primeiros pais o número de vezes que você especifica. Por exemplo, no histórico listado anteriormente, HEAD~3seria

$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
Isso também pode ser escrito HEAD^^^, o que novamente é o primeiro pai do primeiro pai do primeiro pai:

$ git show HEAD^^^
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
Você também pode combinar essas sintaxes - você pode obter o segundo pai da referência anterior (assumindo que seja uma consolidação de mesclagem) usando HEAD~3^2, e assim por diante.

(Faixa de confirmação)
Agora que você pode especificar commits individuais, vamos ver como especificar ranges de commits. Isso é particularmente útil para gerenciar suas filiais - se você tiver muitas ramificações, poderá usar especificações de intervalo para responder perguntas como: "Que trabalho está nessa ramificação que ainda não mesclei em minha ramificação principal?"

(Ponto duplo)
A especificação de intervalo mais comum é a sintaxe de ponto duplo. Isso basicamente pede ao Git para resolver uma série de commits que são alcançáveis ​​a partir de um commit, mas não são alcançáveis ​​de outro. Por exemplo, digamos que você tenha um histórico de confirmação semelhante ao Exemplo de histórico para a seleção de intervalos. .


                    [Figura 137. Exemplo de histórico para seleção de intervalo.]


Você quer ver o que está em sua ramificação experimental que ainda não foi mesclada em sua ramificação principal. Você pode pedir ao Git para mostrar um registro apenas daqueles commits com master..experiment- isso significa “todos os commits alcançáveis ​​por experimentos que não podem ser alcançados pelo master”. Por uma questão de brevidade e clareza nesses exemplos, eu usarei as letras de os objetos de confirmação do diagrama no lugar da saída do log real na ordem em que eles seriam exibidos:

$ git log master..experiment
D
C

Se, por outro lado, você quiser ver o oposto - todos os commits [master] não estão disponíveis experiment- você pode inverter os nomes das ramificações. [experiment..master] mostra tudo que master não pode ser acessado de experiment:

$ git log experiment..master
F
E

Isso é útil se você quiser manter o experimentbranch atualizado e visualizar o que você está prestes a mesclar. Outro uso muito freqüente dessa sintaxe é ver o que você está prestes a empurrar para um controle remoto:

$ git log origin/master..HEAD

Este comando mostra todos os commits em sua ramificação atual que não estão na master ramificação em seu origin controle remoto. Se você executar um git pushe sua ramificação atual estiver rastreando origin/master, as confirmações listadas por git log origin/master..HEAD serão as confirmações que serão transferidas para o servidor. Você também pode deixar um lado da sintaxe para que o Git assuma o HEAD. Por exemplo, você pode obter os mesmos resultados do exemplo anterior digitando git log origin/master..- o Git substitui HEAD se um dos lados estiver faltando.

(Múltiplos Pontos)
A sintaxe de ponto duplo é útil como um atalho; mas talvez você queira especificar mais de duas ramificações para indicar sua revisão, como ver quais commits estão em uma das várias ramificações que não estão na ramificação em que você está atualmente. O Git permite que você faça isso usando o ^caractere ou [--not] antes de qualquer referência a partir da qual você não queira ver os commits alcançáveis. Assim, esses três comandos são equivalentes:

$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA
Isso é bom porque com esta sintaxe você pode especificar mais de duas referências em sua consulta, o que você não pode fazer com a sintaxe de dois pontos. Por exemplo, se você quiser ver todos os commits que são acessíveis a partir de refAou refBmas não a partir refC, você pode digitar um destes:

$ git log refA refB ^refC
$ git log refA refB --not refC
Isso cria um sistema de consulta de revisão muito poderoso que deve ajudá-lo a descobrir o que está em suas ramificações.

(Ponto triplo)
A última sintaxe principal de seleção de intervalo é a sintaxe de ponto triplo, que especifica todas as confirmações que podem ser alcançadas por uma das duas referências, mas não por ambas. Analise o histórico de confirmações de exemplo no Histórico de Exemplo para a seleção de intervalos. . Se você quiser ver o que está em [master] ou [experiment] não há referências comuns, você pode executar

$ git log master...experiment
F
E
D
C

Novamente, isso fornece a logsaída normal, mas mostra apenas as informações de confirmação para essas quatro confirmações, aparecendo na ordem tradicional de data de confirmação.

Um comutador comum para usar com o logcomando neste caso é --left-right, que mostra em qual lado do intervalo cada commit está. Isso ajuda a tornar os dados mais úteis:

$ git log --left-right master...experiment
< F
< E
> D
> C
Com essas ferramentas, você pode deixar o Git saber com mais facilidade quais commits ou commits você quer inspecionar.


7.2 [[ Git Tools - Staging Interativo ]]


*Encenação Interativa
O Git vem com alguns scripts que facilitam algumas tarefas de linha de comando. Aqui, você verá alguns comandos interativos que podem ajudá-lo a criar facilmente seus commits para incluir apenas certas combinações e partes de arquivos. Essas ferramentas são muito úteis se você modificar um monte de arquivos e, em seguida, decidir que deseja que essas alterações sejam feitas em vários commits concentrados, em vez de em um grande commit confuso. Dessa forma, você pode garantir que seus commits sejam conjuntos de alterações logicamente separados e possam ser facilmente revisados ​​pelos desenvolvedores que trabalham com você. Se você executar git addcom a opção [-i] ou [--interactive], o Git entrará em um modo de shell interativo, exibindo algo como isto:

$ git add -i
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now>

Você pode ver que este comando mostra uma visão muito diferente da sua área de teste - basicamente as mesmas informações obtidas, [git status] mas um pouco mais sucintas e informativas. Ele lista as alterações que você criou à esquerda e as alterações não organizadas à direita.

Depois disso vem uma seção de comandos. Aqui você pode fazer várias coisas, incluindo arquivos de teste, desassociar arquivos, preparar partes de arquivos, adicionar arquivos não acompanhados e ver os diffs do que foi testado.

(Preparando e Desvendando Arquivos)
Se você digitar 2ou uno What now>prompt, o script solicitará os arquivos que você deseja encenar:

What now> 2
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update>>

Para preparar os arquivos TODO e index.html, você pode digitar os números:

Update>> 1,2
           staged     unstaged path
* 1:    unchanged        +0/-1 TODO
* 2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update>>
O [*] próximo a cada arquivo significa que o arquivo está selecionado para ser testado. Se você pressionar Enter depois de digitar nada no Update>>prompt, o Git pegará qualquer coisa selecionada e irá prepará-lo para você:

Update>>
updated 2 paths

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now> 1
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

Agora você pode ver que os arquivos TODO e index.html são preparados eo arquivo simplegit.rb ainda não foi empatado. Se você deseja desassociar o arquivo TODO neste ponto, use a opção 3 ou r (para reverter):

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now> 3
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert>> 1
           staged     unstaged path
* 1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert>> [enter]
reverted one path

Olhando para o seu status Git novamente, você pode ver que você tirou o arquivo TODO:

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now> 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

Para ver a diferença do que você preparou, você pode usar o comando 6 ou d (para diff). Ele mostra uma lista dos seus arquivos preparados e você pode selecionar aqueles para os quais gostaria de ver o diff. Isso é muito parecido com a especificação [git diff --cached] na linha de comando:

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now> 6
           staged     unstaged path
  1:        +1/-1      nothing index.html
Review diff>> 1
diff --git a/index.html b/index.html
index 4d07108..4335f49 100644
--- a/index.html
+++ b/index.html
@@ -16,7 +16,7 @@ Date Finder

 <!-- <p id="out">...</p>

-<div id="footer">contact : support@github.com</div>
+<div id="footer">contact : email.support@github.com</div>

 <script type="text/javascript"> -->


Com esses comandos básicos, você pode usar o modo de adição interativa para lidar com sua área de teste com um pouco mais de facilidade.

(Patches de preparação)
Também é possível para o Git encenar certas partes dos arquivos e não o resto. Por exemplo, se você fizer duas alterações em seu arquivo simplegit.rb e quiser encenar uma delas e não a outra, isso é muito fácil no Git. No prompt interativo, digite 5 ou p (para patch). O Git perguntará quais arquivos você gostaria de executar parcialmente; então, para cada seção dos arquivos selecionados, ele exibirá pedaços do arquivo diff e perguntará se você gostaria de encená-los, um por um:

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index dd5ecc4..57399e0 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -22,7 +22,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log -n 25 #{treeish}")
+    command("git log -n 30 #{treeish}")
   end

   def blame(path)
Stage this hunk [ y,n,a,d,/,j,J,g,e,? ] ?

Você tem muitas opções neste momento. Digitar ? mostra uma lista do que você pode fazer:

Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?
y - stage this hunk
n - do not stage this hunk
a - stage this and all the remaining hunks in the file
d - do not stage this hunk nor any of the remaining hunks in the file
g - select a hunk to go to
/ - search for a hunk matching the given regex
j - leave this hunk undecided, see next undecided hunk
J - leave this hunk undecided, see next hunk
k - leave this hunk undecided, see previous undecided hunk
K - leave this hunk undecided, see previous hunk
s - split the current hunk into smaller hunks
e - manually edit the current hunk
? - print help

Geralmente, você digitará you nse quiser encenar cada pedaço, mas encenar todos eles em determinados arquivos ou pular uma decisão do pedaço até mais tarde pode ser útil também. Se você preparar uma parte do arquivo e deixar outra parte não organizada, sua saída de status ficará assim:

What now> 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:        +1/-1        +4/-0 lib/simplegit.rb

O status do arquivo simplegit.rb é interessante. Isso mostra que algumas linhas são encenadas e algumas não são exibidas. Você já colocou parcialmente esse arquivo. Neste ponto, você pode sair do script de adição interativo e executar git commit para confirmar os arquivos parcialmente preparados.

Você também não precisa estar no modo de adição interativa para fazer a preparação parcial do arquivo - você pode iniciar o mesmo script usando [git add -p] ou [git add --patch] na linha de comando.

Além disso, você pode usar o modo de patch para redefinir parcialmente os arquivos com o [reset --patch] comando, para verificar partes de arquivos com o [checkout --patch] comando e para armazenar partes de arquivos com o [stash save --patch] comando. Entraremos em mais detalhes sobre cada um deles, à medida que chegarmos aos usos mais avançados desses comandos.


7.3 [[Ferramentas Git - Estocagem e Limpeza]]

*Estocagem e Limpeza
Muitas vezes, quando você está trabalhando em parte do seu projeto, as coisas estão em um estado confuso e você quer mudar de ramificação um pouco para trabalhar em outra coisa. O problema é que você não quer fazer um commit de trabalho pela metade para poder voltar a esse ponto mais tarde. A resposta para essa questão é o [git stash] comando.

O stashing toma o estado sujo de seu diretório de trabalho - ou seja, seus arquivos rastreados modificados e alterações organizadas - e os salva em uma pilha de alterações inacabadas que você pode reaplicar a qualquer momento (mesmo em uma ramificação diferente).

|Nota
Migrando para git stash push
A partir do final de outubro de 2017, houve uma extensa discussão na lista de discussão do Git, em que o comando git stash saveestá sendo substituído em favor da alternativa existente git stash push. A principal razão para isso é que git stash pushintroduz a opção de esconder pathspecs selecionados , algo git stash saveque não suporta.

git stash savenão vai desaparecer tão cedo, então não se preocupe com isso de repente desaparecendo. Mas você pode querer começar a migrar para a pushalternativa da nova funcionalidade.

(Stashing Your Work)
Para demonstrar stashing, você entrará em seu projeto e começará a trabalhar em alguns arquivos e, possivelmente, encenará uma das alterações. Se você correr git status, você pode ver seu estado sujo:

$ git status
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   lib/simplegit.rb
    
Agora você quer trocar de branch, mas você não quer comprometer o que você está trabalhando ainda; então você vai esconder as mudanças. Para empurrar um novo stash para sua pilha, execute [git stash] ou [git stash save]:

$ git stash
Saved working directory and index state \
  "WIP on master: 049d078 added the index file"
HEAD is now at 049d078 added the index file
(To restore them type "git stash apply")
Agora você pode ver que seu diretório de trabalho está limpo:

$ git status
# On branch master
nothing to commit, working directory clean

Neste ponto, você pode alternar as ramificações e trabalhar em outro lugar; suas alterações são armazenadas na sua pilha. Para ver quais stashes você armazenou, você pode usar g[it stash list]:

$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log

Nesse caso, dois stashes foram feitos anteriormente, então você tem acesso a três diferentes stashed works. Você pode reaplicar o que você acabou escondido usando o comando mostrado na saída ajuda de comando original estoque: [git stash apply]. Se você deseja aplicar um dos esconderijos mais antigos, você pode especificá-lo nomeando-o, como este: [git stash apply stash@{2}]. Se você não especificar um stash, o Git assumirá o stash mais recente e tentará aplicá-lo:

$ git stash apply
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   index.html
	modified:   lib/simplegit.rb

no changes added to commit (use "git add" and/or "git commit -a")

Você pode ver que o Git modifica novamente os arquivos que você revertiu quando salvou o stash. Nesse caso, você tinha um diretório de trabalho limpo quando tentou aplicar o stash e tentou aplicá-lo na mesma ramificação da qual você o salvou. Ter um diretório de trabalho limpo e aplicá-lo na mesma ramificação não é necessário para aplicar com sucesso um stash. Você pode salvar um stash em um branch, alternar para outro branch posteriormente e tentar reaplicar as alterações. Você também pode ter arquivos modificados e não-comprometidos em seu diretório de trabalho quando você aplica um stash - o Git lhe dá conflitos de mesclagem se algo não se aplica mais claramente.

As alterações nos seus arquivos foram reaplicadas, mas o arquivo que você criou antes não foi reexibido. Para fazer isso, você deve executar o [git stash apply] comando com uma [--index] opção para dizer ao comando para tentar reaplicar as alterações preparadas. Se você tivesse feito isso, você teria voltado à sua posição original:

$ git stash apply --index
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   lib/simplegit.rb
    
A opção de aplicar apenas tenta aplicar o trabalho escondido - você continua a tê-lo em sua pilha. Para removê-lo, você pode executar [git stash drop] o nome do stash a ser removido:

$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log
$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)

Você também pode executar [git stash pop] para aplicar o stash e, em seguida, soltá-lo imediatamente de sua pilha.

(Armazenamento criativo)
Existem algumas variantes stash que também podem ser úteis. A primeira opção que é bastante popular é a [--keep-index] opção para o stash save comando. Isso informa ao Git não apenas incluir todo o conteúdo preparado no armazenamento que está sendo criado, mas simultaneamente deixá-lo no índice.

$ git status -s
M  index.html
 M lib/simplegit.rb

$ git stash --keep-index
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
M  index.html  

Outra coisa comum que você pode querer fazer com stash é esconder os arquivos não rastreados, bem como os rastreados. Por padrão, git stasharmazenará apenas arquivos rastreados modificados e em etapas . Se você especificar [--include-untracked] ou [-u], o Git incluirá arquivos não rastreados no stash sendo criado.

$ git status -s
M  index.html
 M lib/simplegit.rb
?? new-file.txt

$ git stash -u
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
$

Finalmente, se você especificar o [--patch] sinalizador, o Git não armazenará tudo o que foi modificado, mas, em vez disso, solicitará interativamente quais das mudanças você gostaria de armazenar e quais gostaria de manter em seu diretório de trabalho.

$ git stash --patch
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 66d332e..8bb5674 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -16,6 +16,10 @@ class SimpleGit
         return `#{git_cmd} 2>&1`.chomp
       end
     end
+
+    def show(treeish = 'master')
+      command("git show #{treeish}")
+    end

 end
 test
Stash this hunk [y,n,q,a,d,/,e,?]? y

Saved working directory and index state WIP on master: 1b65b17 added the index file

(Criando uma ramificação de um estoque)
Se você esconder algum trabalho, deixe-o lá por um tempo e continue na filial da qual você escondeu o trabalho, você pode ter um problema ao reaplicar o trabalho. Se o apply tentar modificar um arquivo que você modificou desde então, você receberá um conflito de mesclagem e terá que tentar resolvê-lo. Se você quiser uma maneira mais fácil de testar as alterações ocultas novamente, é possível executar [git stash branch <branch>], o que cria uma nova ramificação para você com o nome da ramificação selecionada, verifica o commit em que estava quando você ocultou seu trabalho, reaplicou seu trabalho lá e elimina o stash se for aplicado com sucesso:

$ git stash branch testchanges
M	index.html
M	lib/simplegit.rb
Switched to a new branch 'testchanges'
On branch testchanges
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb

Dropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)

Este é um bom atalho para recuperar o trabalho stashed facilmente e trabalhar em um novo ramo.

(Limpando seu diretório de trabalho)
Finalmente, você pode não querer esconder alguns trabalhos ou arquivos em seu diretório de trabalho, mas simplesmente se livrar deles. O [git clean] comando fará isso por você.

Alguns motivos comuns para isso podem ser a remoção de sujeira que foi gerada por mesclagens ou ferramentas externas ou a remoção de artefatos de compilação para executar uma compilação limpa.

Você vai querer ser muito cuidadoso com este comando, uma vez que é projetado para remover arquivos do seu diretório de trabalho que não são rastreados. Se você mudar de ideia, geralmente não há como recuperar o conteúdo desses arquivos. Uma opção mais segura é executar [git stash --all] para remover tudo, mas salvá-lo em um stash.

Supondo que você quer remover arquivos de lixo ou limpar seu diretório de trabalho, você pode fazê-lo com [git clean]. Para remover todos os arquivos não rastreados em seu diretório de trabalho, você pode executar [git clean -f -d], o que remove quaisquer arquivos e também quaisquer subdiretórios que ficam vazios como resultado. A força -f significa ou "realmente faça isso".

Se você quiser ver o que faria, você pode executar o comando com a -nopção, que significa “executar uma execução a seco e me dizer o que você teria removido”.

$ git clean -d -n
Would remove test.o
Would remove tmp/

Por padrão, o [git clean] comando removerá apenas os arquivos não rastreados que não são ignorados. Qualquer arquivo que corresponda a um padrão no seu .gitignore ou em outros arquivos ignorados não será removido. Se você quiser remover esses arquivos também, como remover todos os [.o] arquivos gerados a partir de uma compilação, para poder fazer uma compilação totalmente limpa, você pode adicionar um [-x] ao comando clean.

$ git status -s
 M lib/simplegit.rb
?? build.TMP
?? tmp/

$ git clean -n -d
Would remove build.TMP
Would remove tmp/

$ git clean -n -d -x
Would remove build.TMP
Would remove test.o
Would remove tmp/

Se você não sabe o que o [git clean] comando vai fazer, sempre execute-o com um [-n] primeiro para checar novamente antes de alterar o -npara um [-f] e fazer isso de verdade. A outra maneira de ter cuidado com o processo é executá-lo com o [-i] sinalizador "interativo".

Isso executará o comando clean em um modo interativo.

$ git clean -x -i
Would remove the following items:
  build.TMP  test.o
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit
    6: help
What now>

Dessa forma, você pode percorrer cada arquivo individualmente ou especificar padrões para exclusão interativamente.

|Nota
Há uma situação peculiar em que você pode precisar ser mais vigoroso ao pedir ao Git para limpar seu diretório de trabalho. Se acontecer de você estar em um diretório de trabalho sob o qual você copiou ou clonou outros repositórios Git (talvez como submódulos), até mesmo git clean -fd se recusará a excluir esses diretórios. Em casos como esse, você precisa adicionar uma segunda -f opção para enfatizar.


7.4 [[ Git Tools - assinando seu trabalho ]]


*Assinando seu trabalho
O Git é criptograficamente seguro, mas não é infalível. Se você está tomando o trabalho de outras pessoas na Internet e quer verificar se os commits são realmente de uma fonte confiável, o Git tem algumas maneiras de assinar e verificar o trabalho usando o GPG.

(Introdução ao GPG)
Primeiro de tudo, se você quiser assinar qualquer coisa que você precisa para configurar o GPG e instalar sua chave pessoal.

$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   2048R/0A46826A 2014-06-04
uid                  Scott Chacon (Git signing key) <schacon@gmail.com>
sub   2048R/874529A9 2014-06-04

Se você não tiver uma chave instalada, poderá gerar uma com [gpg --gen-key].

$ gpg --gen-key

Depois de ter uma chave privada para assinar, você pode configurar o Git para usá-lo para assinar as coisas, definindo a [user.signingkey] configuração.

$ git config --global user.signingkey 0A46826A
Agora o Git usará sua chave por padrão para assinar tags e commits se você quiser.

(Tags de assinatura)
Se você tiver uma configuração de chave privada GPG, poderá usá-la para assinar novas tags. Tudo que você precisa fazer é usar em [-s] vez de [-a]:

$ git tag -s v1.5 -m 'my signed 1.5 tag'

You need a passphrase to unlock the secret key for
user: "Ben Straub <ben@straub.cc>"
2048-bit RSA key, ID 800430EB, created 2014-05-04
Se você executar [git show] essa tag, poderá ver sua assinatura de GPG anexada a ela:

$ git show v1.5
tag v1.5
Tagger: Ben Straub <ben@straub.cc>
Date:   Sat May 3 20:29:41 2014 -0700

my signed 1.5 tag
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQEcBAABAgAGBQJTZbQlAAoJEF0+sviABDDrZbQH/09PfE51KPVPlanr6q1v4/Ut
LQxfojUWiLQdg2ESJItkcuweYg+kc3HCyFejeDIBw9dpXt00rY26p05qrpnG+85b
hM1/PswpPLuBSr+oCIDj5GMC2r2iEKsfv2fJbNW8iWAXVLoWZRF8B0MfqX/YTMbm
ecorc4iXzQu7tupRihslbNkfvfciMnSDeSvzCpWAHl7h8Wj6hhqePmLm9lAYqnKp
8S5B/1SSQuEAjRZgI4IexpZoeKGVDptPHxLLS38fozsyi0QyDyzEgJxcJQVMXxVi
RUysgqjcpT8+iQM1PblGfHR4XAhuOqN5Fx06PSaFZhqvWFezJ28/CLyX5q+oIVk=
=EFTF
-----END PGP SIGNATURE-----

commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number


(Verificando tags)
Para verificar uma tag assinada, você usa [git tag -v <tag-name>]. Este comando usa o GPG para verificar a assinatura. Você precisa da chave pública do assinante no seu chaveiro para que isso funcione corretamente:

$ git tag -v v1.4.2.1
object 883653babd8ee7ea23e6a5c392bb739348b1eb61
type commit
tag v1.4.2.1
tagger Junio C Hamano <junkio@cox.net> 1158138501 -0700

GIT 1.4.2.1

Minor fixes since 1.4.2, including git-mv and git-http with alternates.
gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Good signature from "Junio C Hamano <junkio@cox.net>"
gpg:                 aka "[jpeg image of size 1513]"
Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A
Se você não tem a chave pública do assinante, você obtém algo assim:

gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Can't check signature: public key not found
error: could not verify the tag 'v1.4.2.1'


(Compromissos de Assinatura)
Em versões mais recentes do Git (v1.7.9 e posteriores), agora você também pode assinar commits individuais. Se você estiver interessado em assinar confirmações diretamente, em vez de apenas as tags, tudo o que você precisa fazer é adicionar um -Sao seu [git commit] comando.

$ git commit -a -S -m 'signed commit'

You need a passphrase to unlock the secret key for
user: "Scott Chacon (Git signing key) <schacon@gmail.com>"
2048-bit RSA key, ID 0A46826A, created 2014-06-04

[master 5c3386c] signed commit
 4 files changed, 4 insertions(+), 24 deletions(-)
 rewrite Rakefile (100%)
 create mode 100644 lib/git.rb
Para ver e verificar essas assinaturas, há também uma [--show-signature] opção para [git log].

$ git log --show-signature -1
commit 5c3386cf54bba0a33a32da706aa52bc0155503c2
gpg: Signature made Wed Jun  4 19:49:17 2014 PDT using RSA key ID 0A46826A
gpg: Good signature from "Scott Chacon (Git signing key) <schacon@gmail.com>"
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Jun 4 19:49:17 2014 -0700

    signed commit
Além disso, você pode configurar git logpara verificar quaisquer assinaturas encontradas e listá-las em sua saída com o [%G?] formato.

$ git log --pretty="format:%h %G? %aN  %s"

5c3386c G Scott Chacon  signed commit
ca82a6d N Scott Chacon  changed the version number
085bb3b N Scott Chacon  removed unnecessary test code
a11bef0 N Scott Chacon  first commit

Aqui podemos ver que apenas o último commit é assinado e válido e os commits anteriores não são.

No Git 1.8.3 e posterior, [git merge] e [git pull] pode ser dito para inspecionar e rejeitar ao mesclar um commit que não carrega uma assinatura GPG confiável com o [--verify-signatures] comando.

Se você usar essa opção ao mesclar uma ramificação e contiver confirmações que não sejam assinadas e válidas, a mesclagem não funcionará.

$ git merge --verify-signatures non-verify
fatal: Commit ab06180 does not have a GPG signature.

Se a mesclagem contiver somente confirmações assinadas válidas, o comando de mesclagem mostrará todas as assinaturas que ele verificou e, em seguida, avançará com a mesclagem.

$ git merge --verify-signatures signed-branch
Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) <schacon@gmail.com>
Updating 5c3386c..13ad65e
Fast-forward
 README | 2 ++
 1 file changed, 2 insertions(+)

Você também pode usar a -Sopção com o git mergecomando para assinar a consolidação de mesclagem resultante. O exemplo a seguir verifica se todo commit na ramificação a ser mesclada é assinado e, além disso, assina a confirmação de mesclagem resultante.

$ git merge --verify-signatures -S  signed-branch
Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) <schacon@gmail.com>

You need a passphrase to unlock the secret key for
user: "Scott Chacon (Git signing key) <schacon@gmail.com>"
2048-bit RSA key, ID 0A46826A, created 2014-06-04

Merge made by the 'recursive' strategy.
 README | 2 ++
 1 file changed, 2 insertions(+)

(Todos devem assinar)
Assinar tags e commits é ótimo, mas se você decidir usar isso em seu fluxo de trabalho normal, precisará garantir que todos em sua equipe entendam como fazer isso. Se não o fizer, você acabará gastando muito tempo ajudando as pessoas a descobrir como reescrever seus commits com versões assinadas. Certifique-se de entender o GPG e os benefícios de assinar as coisas antes de adotar isso como parte de seu fluxo de trabalho padrão.



7.5 [[ Git Tools - Pesquisando ]]

*Procurando
Com praticamente qualquer base de código de tamanho, muitas vezes você precisa encontrar onde uma função é chamada ou definida, ou exibir o histórico de um método. O Git fornece algumas ferramentas úteis para examinar o código e confirma o armazenamento em seu banco de dados com rapidez e facilidade. Nós vamos passar por alguns deles.

(Git Grep)
O Git é fornecido com um comando chamado grep que permite pesquisar facilmente qualquer árvore consolidada, o diretório de trabalho ou até mesmo o índice de uma string ou expressão regular. Para os exemplos a seguir, pesquisaremos o código-fonte para o próprio Git.

Por padrão, [git grep] irá procurar pelos arquivos em seu diretório de trabalho. Como primeira variação, você pode usar uma das opções [-n] ou [--line-number] para imprimir os números de linha onde o Git encontrou correspondências:

$ git grep -n gmtime_r
compat/gmtime.c:3:#undef gmtime_r
compat/gmtime.c:8:      return git_gmtime_r(timep, &result);
compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm *result)
compat/gmtime.c:16:     ret = gmtime_r(timep, result);
compat/mingw.c:826:struct tm *gmtime_r(const time_t *timep, struct tm *result)
compat/mingw.h:206:struct tm *gmtime_r(const time_t *timep, struct tm *result);
date.c:482:             if (gmtime_r(&now, &now_tm))
date.c:545:             if (gmtime_r(&time, tm)) {
date.c:758:             /* gmtime_r() in match_digit() may have clobbered it */
git-compat-util.h:1138:struct tm *git_gmtime_r(const time_t *, struct tm *);
git-compat-util.h:1140:#define gmtime_r git_gmtime_r

Além da pesquisa básica mostrada acima, git grep suporta uma infinidade de outras opções interessantes.

Por exemplo, em vez de imprimir todas as correspondências, você pode pedir git grep para resumir a saída mostrando apenas quais arquivos continham a string de pesquisa e quantas correspondências havia em cada arquivo com a opção [-c] ou [--count]:

$ git grep --count gmtime_r
compat/gmtime.c:4
compat/mingw.c:1
compat/mingw.h:1
date.c:3
git-compat-util.h:2

Se você estiver interessado no contexto de uma string de pesquisa, poderá exibir o método ou função de inclusão para cada string correspondente com uma das opções [-p] ou [--show-function]:

$ git grep -p gmtime_r *.c
date.c=static int match_multi_number(timestamp_t num, char c, const char *date,
date.c:         if (gmtime_r(&now, &now_tm))
date.c=static int match_digit(const char *date, struct tm *tm, int *offset, int *tm_gmt)
date.c:         if (gmtime_r(&time, tm)) {
date.c=int parse_date_basic(const char *date, timestamp_t *timestamp, int *offset)
date.c:         /* gmtime_r() in match_digit() may have clobbered it */

Como você pode ver, a [gmtime_r] rotina é chamada pelas funções [match_multi_number] e [match_digit] no [date.c] arquivo (a terceira correspondência exibida representa apenas a string que aparece em um comentário).

Você também pode pesquisar combinações complexas de strings com o [--and] sinalizador, o que garante que várias correspondências devem ocorrer na mesma linha de texto. Por exemplo, vamos procurar por qualquer linha que defina uma constante cujo nome contenha qualquer uma das substrings “LINK” ou “BUF_MAX”, especificamente em uma versão mais antiga da base de código do Git representada pela tag v1.8.0(vamos lançar as opções [--break] e [--heading] ajudar a dividir a saída em um formato mais legível):

$ git grep --break --heading \
    -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0
v1.8.0:builtin/index-pack.c
62:#define FLAG_LINK (1u<<20)

v1.8.0:cache.h
73:#define S_IFGITLINK  0160000
74:#define S_ISGITLINK(m)       (((m) & S_IFMT) == S_IFGITLINK)

v1.8.0:environment.c
54:#define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKS

v1.8.0:strbuf.c
326:#define STRBUF_MAXLINK (2*PATH_MAX)

v1.8.0:symlinks.c
53:#define FL_SYMLINK  (1 << 2)

v1.8.0:zlib.c
30:/* #define ZLIB_BUF_MAX ((uInt)-1) */
31:#define ZLIB_BUF_MAX ((uInt) 1024 * 1024 * 1024) /* 1GB */

O git grep comando tem algumas vantagens sobre os comandos normais de pesquisa, como [grep] e [ack]. A primeira é que é muito rápido, o segundo é que você pode pesquisar em qualquer árvore no Git, não apenas no diretório de trabalho. Como vimos no exemplo acima, procuramos termos em uma versão mais antiga do código-fonte do Git, não a versão que estava com check-out no momento.



(Pesquisa de log do Git)

Talvez você está olhando não para onde existe um termo, mas quando ele existia ou foi introduzido. O git logcomando tem um número de ferramentas poderosas para encontrar commits específicos pelo conteúdo de suas mensagens ou até mesmo pelo conteúdo do diff que eles introduzem.

Se, por exemplo, quisermos descobrir quando a ZLIB_BUF_MAX constante foi originalmente introduzida, podemos usar a -Sopção (coloquialmente chamada de opção “pickaxe” do Git) para dizer ao Git para nos mostrar apenas os commits que mudaram o número de ocorrências de essa cadeia.

$ git log -S ZLIB_BUF_MAX --oneline
e01503b zlib: allow feeding more than 4GB in one go
ef49a7a zlib: zlib can only process 4GB at a time

Se olharmos para o diff desses commits, podemos ver que na ef49a7a constante foi introduzida e e01503b nela foi modificada.

Se você precisar ser mais específico, forneça uma expressão regular para pesquisar com a [-G] opção.



(Pesquisa de registro de linha)

Outra pesquisa de log bastante avançada que é insanamente útil é a pesquisa do histórico de linha. Basta executar [git log] a [-L] opção e ela mostrará o histórico de uma função ou linha de código na sua base de código.

Por exemplo, se quiséssemos ver todas as alterações feitas na função [git_deflate_bound] no [zlib.c] arquivo, poderíamos executá-la [git log -L :git_deflate_bound:zlib.c]. Isso tentará descobrir quais são os limites dessa função e, em seguida, examinar o histórico e nos mostrar todas as alterações feitas na função como uma série de correções de quando a função foi criada pela primeira vez.

$ git log -L :git_deflate_bound:zlib.c
commit ef49a7a0126d64359c974b4b3b71d7ad42ee3bca
Author: Junio C Hamano <gitster@pobox.com>
Date:   Fri Jun 10 11:52:15 2011 -0700

    zlib: zlib can only process 4GB at a time

diff --git a/zlib.c b/zlib.c
--- a/zlib.c
+++ b/zlib.c
@@ -85,5 +130,5 @@
-unsigned long git_deflate_bound(z_streamp strm, unsigned long size)
+unsigned long git_deflate_bound(git_zstream *strm, unsigned long size)
 {
-       return deflateBound(strm, size);
+       return deflateBound(&strm->z, size);
 }


commit 225a6f1068f71723a910e8565db4e252b3ca21fa
Author: Junio C Hamano <gitster@pobox.com>
Date:   Fri Jun 10 11:18:17 2011 -0700

    zlib: wrap deflateBound() too

diff --git a/zlib.c b/zlib.c
--- a/zlib.c
+++ b/zlib.c
@@ -81,0 +85,5 @@
+unsigned long git_deflate_bound(z_streamp strm, unsigned long size)
+{
+       return deflateBound(strm, size);
+}
+

Se o Git não conseguir descobrir como combinar uma função ou método na sua linguagem de programação, você também poderá fornecer uma expressão regular (ou regex ). Por exemplo, isso teria feito a mesma coisa que o exemplo acima: [git log -L '/unsigned long]  [git_deflate_bound/',/^}/:zlib.c]. Você também pode fornecer um intervalo de linhas ou um único número de linha e obterá o mesmo tipo de saída.


7.6 [[ Ferramentas do Git - Reescrevendo a História ]]

*Reescrevendo História
Muitas vezes, ao trabalhar com o Git, você pode querer revisar seu histórico de commits local. Uma das grandes coisas sobre o Git é que ele permite que você tome decisões no último momento possível. Você pode decidir quais arquivos vão para quais commits antes de se comprometer com a área temporária, você pode decidir que você não queria trabalhar em algo ainda git stash, e você pode reescrever commits que já aconteceram para que eles pareçam ter acontecido em um caminho diferente. Isso pode envolver alterar a ordem dos commits, alterar mensagens ou modificar arquivos em um commit, esmagar ou dividir commits, ou remover commits completamente - tudo antes de compartilhar seu trabalho com outras pessoas.

Nesta seção, você verá como realizar essas tarefas para tornar seu histórico de commits do jeito que deseja antes de compartilhá-lo com outras pessoas.

|Nota
Uma das regras principais do Git é que, como muito trabalho é local dentro do seu clone, você tem muita liberdade para reescrever sua história localmente . No entanto, uma vez que você empurra o seu trabalho, é uma história completamente diferente, e você deve considerar o trabalho empurrado como final, a menos que você tenha uma boa razão para alterá-lo. Em suma, você deve evitar empurrar o seu trabalho até ficar satisfeito e pronto para compartilhá-lo com o resto do mundo.



(Mudando o último commit)
Mudar seu commit mais recente é provavelmente a reescrita mais comum da história que você fará. Com frequência, você quer fazer duas coisas básicas em seu último commit: basta alterar a mensagem de confirmação ou alterar o conteúdo real da confirmação, adicionando, removendo e modificando arquivos.

Se você simplesmente quer modificar sua última mensagem de commit, é fácil:

$ git commit --amend

O comando acima carrega a mensagem de confirmação anterior em uma sessão do editor, na qual você pode fazer alterações na mensagem, salvar essas alterações e sair. Quando você salva e fecha o editor, o editor grava uma nova confirmação contendo essa mensagem de confirmação atualizada e a transforma no seu último último commit.

Se, por outro lado, você quiser alterar o conteúdo real do seu último commit, o processo funciona basicamente da mesma maneira - primeiro faça as mudanças que você acha que esqueceu, encene essas mudanças, e o subsequente [git commit --amend] substitui o último commit pelo seu novo commit. , melhorou o commit.

Você precisa ter cuidado com essa técnica, porque alterar altera o SHA-1 do commit. É como um rebase muito pequeno - não altere seu último commit se você já o tiver pressionado.

|tip - Gorjeta
Um commit alterado pode (ou não) precisar de uma mensagem de commit alterada
Quando você altera uma confirmação, você tem a oportunidade de alterar a mensagem de confirmação e o conteúdo da confirmação. Se você alterar substancialmente o conteúdo do commit, você deve quase certamente atualizar a mensagem de commit para refletir esse conteúdo alterado.

Por outro lado, se as suas alterações forem adequadamente triviais (consertando um erro bobo ou adicionando um arquivo que você esqueceu de encenar) de forma que a mensagem anterior de commit seja boa, você pode simplesmente fazer as mudanças, encená-las e evitar o editor desnecessário. sessão inteiramente com:

$ git commit --amend --no-edit

(Alterando Várias Mensagens de Confirmação)
Para modificar um commit que está mais para trás no seu histórico, você deve passar para ferramentas mais complexas. O Git não tem uma ferramenta de modificação de histórico, mas você pode usar a ferramenta de rebase para rebase de uma série de commits no HEAD no qual eles foram originalmente baseados em vez de movê-los para outro. Com a ferramenta de rebase interativa, você pode parar depois de cada consolidação que deseja modificar e alterar a mensagem, adicionar arquivos ou fazer o que quiser. Você pode executar rebase de forma interativa adicionando a -iopção para git rebase. Você deve indicar o quão longe você deseja reescrever os commits, dizendo ao comando qual commit deve ser rebase.

Por exemplo, se você deseja alterar as três últimas mensagens de confirmação ou qualquer uma das mensagens de confirmação nesse grupo, forneça como um argumento para [git rebase -i] o pai da última confirmação que deseja editar, que é HEAD~2^ou HEAD~3. Pode ser mais fácil lembrar do ~3porque você está tentando editar os três últimos commits, mas lembre-se de que você está realmente designando quatro commits atrás, o pai do último commit que você deseja editar:

$ git rebase -i HEAD~3

Lembre-se novamente que este é um comando de rebase - cada commit incluído no range HEAD~3..HEAD será reescrito, quer você mude a mensagem ou não. Não inclua nenhum commit que você já tenha enviado para um servidor central - isso confundirá outros desenvolvedores, fornecendo uma versão alternativa da mesma alteração.

Executar este comando fornece uma lista de commits no seu editor de texto que se parece com isto:

pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out

É importante observar que esses commits estão listados na ordem oposta do que você normalmente os vê usando o [log] comando. Se você executar um log, você verá algo como isto:

$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
Observe a ordem inversa. O rebase interativo fornece um script que será executado. Ele iniciará no commit especificado na linha de comando ( HEAD~3) e reproduzirá as alterações introduzidas em cada uma dessas confirmações de cima para baixo. Ele lista o mais antigo no topo, e não o mais recente, porque esse é o primeiro que será reproduzido.

Você precisa editar o script para que ele pare no commit que você deseja editar. Para fazer isso, mude a palavra 'pick' para a palavra 'edit' para cada um dos commits que você quer que o script pare depois. Por exemplo, para modificar apenas a terceira mensagem de confirmação, altere o arquivo para ficar assim:

edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

Quando você salva e sai do editor, o Git retrocede de volta ao último commit da lista e coloca você na linha de comando com a seguinte mensagem:

$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue

Estas instruções dizem exatamente o que fazer. Tipo

$ git commit --amend

Altere a mensagem de confirmação e saia do editor. Então corra

$ git rebase --continue

Este comando irá aplicar os outros dois commits automaticamente, e então você está pronto. Se você alterar a escolha para editar em mais linhas, poderá repetir essas etapas para cada consolidação que você alterar para editar. A cada vez, o Git parará, permitirá que você altere o commit e continuará quando terminar.

(Reordenando Commits)
Você também pode usar repositórios interativos para reordenar ou remover totalmente os commits. Se você quiser remover o commit “arquivo de catogo adicionado” e mudar a ordem em que os outros dois commits são introduzidos, você pode mudar o script de rebase a partir deste

pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

para isso:

pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
Quando você salva e sai do editor, o Git rebobina sua ramificação para o pai desses commits, aplica 310154e- se e f7f3f6d, em seguida , pára. Você efetivamente altera a ordem desses commits e remove completamente o commit “added cat-file”.

(Compromissos de esmagamento)
Também é possível fazer uma série de commits e esmagá-los em um único commit com a ferramenta de re-criação interativa. O script coloca instruções úteis na mensagem de rebase:

#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out

Se, ao invés de “escolher” ou “editar”, você especificar “squash”, o Git aplica a mudança e a mudança diretamente antes dela e faz com que você mescle as mensagens de commit juntas. Então, se você quiser fazer um único commit destes três commits, você faz o script parecer assim:

pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file

Quando você salva e sai do editor, o Git aplica as três alterações e, em seguida, coloca você de volta no editor para mesclar as três mensagens de confirmação:

# This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file

Quando você salva isso, você tem um único commit que introduz as mudanças de todos os três commits anteriores.

(Dividindo um Commit)
Dividir um commit desfaz um commit e, em seguida, parcializa e efetua commits tantas vezes quanto os commits que você quer terminar. Por exemplo, suponha que você queira dividir a confirmação intermediária de seus três commits. Em vez de “formatação README atualizada e adição de culpa”, você deseja dividi-la em duas confirmações: “formatação README atualizada” para a primeira e “culpa adicional” na segunda. Você pode fazer isso no [rebase -i] script alterando a instrução no commit que você quer dividir para “editar”:

pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

Então, quando o script direciona você para a linha de comando, você redefine essa confirmação, aceita as alterações que foram redefinidas e cria vários commits delas. Quando você salva e sai do editor, o Git retrocede para o pai do primeiro commit da sua lista, aplica o primeiro commit ( f7f3f6d), aplica o segundo ( 310154e) e o coloca no console. Lá, você pode fazer uma reconfiguração mista desse commit git reset HEAD^, o que efetivamente desfaz o commit e deixa os arquivos modificados desassociados. Agora você pode organizar e confirmar arquivos até ter vários commits e ser executado [git rebase --continue] quando terminar:

$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue

O Git aplica o último commit ( a5f4a0d) no script, e seu histórico se parece com isto:

$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
Mais uma vez, isso muda os SHA-1s de todos os commits da sua lista, então certifique-se de que nenhum commit apareça naquela lista que você já tenha enviado para um repositório compartilhado.

(A Opção Nuclear: filtro-ramo)
Há outra opção de reescrever o histórico que você pode usar se precisar reescrever um número maior de commits de alguma maneira programável - por exemplo, alterando seu endereço de email globalmente ou removendo um arquivo de cada commit. O comando é [filter-branch], e pode reescrever grandes extensões do seu histórico, então você provavelmente não deve usá-lo a menos que seu projeto ainda não seja público e outras pessoas não tenham baseado o trabalho dos commits que você está prestes a reescrever. No entanto, isso pode ser muito útil. Você aprenderá alguns dos usos comuns para ter uma ideia de algumas das coisas de que é capaz.

(Removendo um arquivo de cada confirmação)
Isso ocorre com bastante frequência. Alguém acidentalmente comete um imenso arquivo binário sem pensar [git add .], e você quer removê-lo em todos os lugares. Talvez você tenha acidentalmente enviado um arquivo que continha uma senha e deseje tornar seu projeto open source. [filter-branch] é a ferramenta que você provavelmente quer usar para limpar todo o histórico. Para remover um arquivo [passwords.txt] de seu histórico inteiro, você pode usar a --tree-filteropção para filter-branch:

$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten

A [--tree-filter] opção executa o comando especificado após cada verificação do projeto e, em seguida, compromete os resultados novamente. Nesse caso, você remove um arquivo chamado passwords.txtde todos os instantâneos, independentemente de existir ou não. Se você quiser remover todos os arquivos de backup do editor ativados acidentalmente, execute algo como [git filter-branch --tree-filter 'rm -f *~' HEAD].

Você será capaz de assistir ao Git reescrevendo árvores e commits e, em seguida, mover o ponteiro da ramificação no final. Em geral, é uma boa ideia fazer isso em uma ramificação de teste e, em seguida, redefinir sua ramificação mestre depois de determinar que o resultado é o que você realmente deseja. Para correr [filter-branch] em todos os seus ramos, você pode passar [--all] para o comando.

(Tornando um subdiretório a nova raiz)
Suponha que você tenha feito uma importação de outro sistema de controle de origem e ter subdiretórios que não fazem sentido ( trunk, tags e assim por diante). Se você quiser que o trunksubdiretório seja a nova raiz do projeto para cada commit, filter-branchpode ajudá-lo a fazer isso também:

$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten

Agora, o novo projeto raiz é o que estava no [trunk] subdiretório a cada vez. O Git também removerá automaticamente os commits que não afetaram o subdiretório.

(Alterando endereços de email globalmente)
Outro caso comum é que você se esqueceu de executar [git config] para definir seu nome e endereço de e-mail antes de começar a trabalhar, ou talvez queira abrir um projeto no trabalho e alterar todos os seus endereços de e-mail de trabalho para seu endereço pessoal. Em qualquer caso, você também pode alterar endereços de e-mail em várias confirmações em um lote [filter-branch]. Você precisa ter cuidado para alterar apenas os endereços de e-mail que são seus, então use [--commit-filter]:

$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD

Isso passa e reescreve todos os commits para ter seu novo endereço. Como as confirmações contêm os valores SHA-1 de seus pais, esse comando altera todos os commits SHA-1 em seu histórico, não apenas aqueles que têm o endereço de email correspondente.


7.7 [[ Git Tools - Redefinir Desmistificado ]]

*Redefinir Desmistificado
Antes de passar para ferramentas mais especializadas, vamos falar sobre o [Git resete] os [checkout] comandos. Esses comandos são duas das partes mais confusas do Git quando você os encontra pela primeira vez. Eles fazem tantas coisas que parece impossível entendê-los e empregá-los corretamente. Para isso, recomendamos uma metáfora simples.

(As três árvores)
Uma maneira mais fácil de pensar reset e checkout é através do quadro mental de Git sendo um gerenciador de conteúdo de três árvores diferentes. Por “árvore” aqui, nós realmente queremos dizer “coleção de arquivos”, não especificamente a estrutura de dados. (Existem alguns casos em que o índice não funciona exatamente como uma árvore, mas, para nossos propósitos, é mais fácil pensar dessa forma por enquanto.)

Git como um sistema gerencia e manipula três árvores em sua operação normal:

| Árvore |	                                         | Função |

HEAD                                            Ultima confirmação instantânea, próximo pai

Index                                          Proposta para o próximo instantâneo de confirmação

Working Diretory (Diretório de trabalho)        Sandbox  (Caixa de areia) 



(A HEAD)
HEAD é o ponteiro para a referência de ramificação atual, que por sua vez é um ponteiro para o último commit feito nesse branch. Isso significa que o HEAD será o pai do próximo commit criado. Geralmente é mais simples pensar em HEAD como o instantâneo do seu último commit nesse branch .

Na verdade, é muito fácil ver como é esse instantâneo. Aqui está um exemplo de obter a listagem de diretórios real e somas de verificação SHA-1 para cada arquivo no instantâneo HEAD:

$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib

O Git [cat-filee os ls-tree] comandos são comandos de “encanamento” que são usados ​​para coisas de baixo nível e não são realmente usados ​​no trabalho do dia-a-dia, mas nos ajudam a ver o que está acontecendo aqui.

(O INDEX)
O índice é o seu próximo commit proposto . Nós também estamos nos referindo a este conceito como a “Staging Area” do Git, pois é isso que o Git observa quando você corre [git commit].

O Git preenche este índice com uma lista de todos os conteúdos dos arquivos que foram verificados pela última vez em seu diretório de trabalho e como eles se pareciam quando foram originalmente retirados. Em seguida, você substitui alguns desses arquivos por novas versões deles e os git commit converte na árvore para um novo commit.

$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb

Novamente, aqui estamos usando [git ls-files], que é mais um comando por trás das cenas que mostra como seu índice se parece atualmente.

O índice não é tecnicamente uma estrutura de árvore - na verdade, é implementado como um manifesto achatado - mas, para nossos propósitos, é próximo o suficiente.


(O diretório de trabalho)
Finalmente, você tem seu diretório de trabalho. As outras duas árvores armazenam seu conteúdo de maneira eficiente, mas inconveniente, dentro da [.git] pasta. O diretório de trabalho os descompacta em arquivos reais, o que torna muito mais fácil editá-los. Pense no diretório de trabalho como um sandbox , onde você pode experimentar as alterações antes de enviá-las para sua área de armazenamento temporário (index) e, em seguida, para o histórico.

$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files


(O fluxo de trabalho)
O principal objetivo do Git é registrar instantâneos de seu projeto em estados sucessivamente melhores, manipulando essas três árvores.


                                 [   figure -138 -redefinir o fluxo de trabalho  ]



Vamos visualizar esse processo: digamos que você vá para um novo diretório com um único arquivo. Vamos chamar isso de v1 do arquivo e vamos indicá-lo em azul. Agora vamos rodar [git init], o que criará um repositório Git com uma referência HEAD que aponta para um branch masternão nascido ( não existe ainda).



                             [   figure -139 -redefinir 01]



Neste ponto, apenas a árvore do Working Directory possui algum conteúdo.

Agora queremos cometer este arquivo, então usamos o git addconteúdo no diretório de trabalho e copiá-lo para o índice.
                    

                            [   figure -140 -redefinir 02]



Em seguida, executamos [git commit], o que leva o conteúdo do Index e o salva como um instantâneo permanente, cria um objeto de confirmação que aponta para esse instantâneo e atualiza masterpara apontar para esse commit.


                        
                            [   figure -141 -redefinir 03]



Se corrermos [git status], não veremos mudanças, porque todas as três árvores são iguais.

Agora queremos fazer uma alteração nesse arquivo e enviá-lo. Nós vamos passar pelo mesmo processo; Primeiro nós mudamos o arquivo em nosso diretório de trabalho. Vamos chamar isso de v2 do arquivo e indicar em vermelho.



                            [   figure -142 -redefinir 04  ]



Se executarmos[git status] agora, veremos o arquivo em vermelho como "Alterações não preparadas para confirmação", porque essa entrada difere entre o índice e o diretório de trabalho. Em seguida, corremos [git add] para colocá-lo em nosso índice.


                            [   figure -143 -redefinir 05   ]



Neste ponto, se executarmos [git status], veremos o arquivo em verde em “Changes to be committed” porque o Index e o HEAD diferem - isto é, o próximo commit proposto agora é diferente do nosso último commit. Finalmente, corremos [git commit] para finalizar o commit.



                                [  figure -144 -redefinir 06 ]


 
Agora[] git status] não nos dará saída, porque todas as três árvores são iguais novamente.

A alternância de ramificações ou clonagem passa por um processo semelhante. Quando você faz o checkout de uma ramificação, ela muda de HEAD para apontar para a nova ref de ramificação, preenche seu INDEX com o instantâneo dessa confirmação e, em seguida, copia o conteúdo do INDEX para sua pasta de trabalho .



(O papel do reset)
O [reset] comando faz mais sentido quando visto neste contexto.

Para os propósitos desses exemplos, digamos que modificamos file.txt novamente e confirmamos pela terceira vez. Então agora nossa história se parece com isso:

 

                            [  figure -145 - reset start]


Vamos agora percorrer exatamente o resetque você chama. Ele manipula diretamente essas três árvores de maneira simples e previsível. Faz até três operações básicas.

(Etapa 1: Mova o HEAD)
A primeira coisa que resetvai fazer é mover o que HEAD aponta. Isso não é o mesmo que mudar o próprio HEAD (que é o que checkout faz); reset move o ramo para o qual o HEAD está apontando. Isso significa que se o HEAD estiver definido para o master ramo (ou seja, você está atualmente no master ramo), a execução git reset 9e5e6a4começará master apontando para 9e5e6a4.


                        [  figure -146 - reset suave]



Não importa que forma de resetcommit você invoque, essa é a primeira coisa que sempre tentará fazer. Com [reset --soft] isso, simplesmente parará por aí.

Agora, analise o diagrama e perceba o que aconteceu: ele basicamente desfez o último git commit comando. Quando você executa git commit, o Git cria um novo commit e move o branch que HEAD aponta para ele. Quando você reset volta para HEAD~(o pai de HEAD), você está movendo o ramo de volta para onde estava, sem alterar o índice ou a pasta de trabalho. Agora você pode atualizar o índice e executá-lo git commit novamente para realizar o git commit --amend que teria feito (consulte Alterando o último commit ).



(Etapa 2: Atualizando o Índice (--misturado))
Note que se você correr git status agora, verá em verde a diferença entre o Index e o novo HEAD.

A próxima coisa que resetvai fazer é atualizar o Index com o conteúdo de qualquer instantâneo que o HEAD agora apontar.

 

                        [  figure -147 - redefinir misturado]




Se você especificar a [--mixed] opção, [reset] parará nesse ponto. Este também é o padrão, portanto, se você não especificar nenhuma opção (apenas [git reset HEAD~] nesse caso), é nesse ponto que o comando será interrompido.

Agora, dê mais um segundo para olhar para esse diagrama e perceber o que aconteceu: ele ainda desfez sua última commit, mas também unstaged tudo. Você rolou de volta para antes de executar todos os seus git add e git commit comandos.


(Etapa 3: Atualizando o Diretório de Trabalho (--hard))
A terceira coisa que reset vai fazer é fazer com que o Working Directory se pareça com o Index. Se você usar a [--hard] opção, ela continuará nesse estágio.


                            [  figure -148 - redefinir]


Então vamos pensar sobre o que aconteceu. Você desfez seu último commit, o git adde git commitcomandos, e todo o trabalho que você fez no seu diretório de trabalho.

É importante notar que essa flag ( --hard) é a única maneira de tornar o resetcomando perigoso, e um dos poucos casos em que o Git realmente destruirá os dados. Qualquer outra invocação de resetpode ser facilmente desfeita, mas a --hardopção não pode, uma vez que forçosamente sobrescreve arquivos no diretório de trabalho. Neste caso em particular, nós ainda temos a versão v3 do nosso arquivo em um commit no nosso Git DB, e nós poderíamos recuperá-lo olhando para o nosso reflog, mas se nós não tivéssemos cometido isso, o Git ainda teria sobrescrito o arquivo e ele seria irrecuperável.

(Recapitular)
O reset comando sobrescreve essas três árvores em uma ordem específica, parando quando você diz para:

1. Mova os pontos HEAD da ramificação para (pare aqui se --soft)
2. Faça o índice parecer CABEÇA (pare aqui a menos que --hard)
3. Tornar o diretório de trabalho parecido com o índice

(Redefinir com um caminho)
Isso cobre o comportamento de reset sua forma básica, mas você também pode fornecer um caminho para agir. Se você especificar um caminho, resetignorará a etapa 1 e limitará o restante de suas ações a um arquivo ou conjunto de arquivos específico. Isso realmente faz sentido - HEAD é apenas um ponteiro, e você não pode apontar parte de um commit e parte de outro. Mas o índice e o diretório Working podem ser parcialmente atualizados, portanto, a reinicialização prossegue com as etapas 2 e 3.

Então, suponha que corremos git reset file.txt. Este formulário (desde que você não especificou um commit SHA-1 ou branch, e você não especificou --softou --hard) é um atalho para git reset --mixed HEAD file.txt, que irá:

1. Mova os pontos HEAD da ramificação para (ignorado)
2. Faça o índice parecer CABEÇA (pare aqui)

Então, basicamente, apenas copia file.txtde HEAD para o Index.



                    [  figure -149 - redefinir caminho1]


Isso tem o efeito prático de desassociar o arquivo. Se olharmos para o diagrama para esse comando e pensarmos sobre o que git add acontece, eles são opostos exatos.



                    [  figure -150 - redefinir caminho2]


É por isso que a saída do git status comando sugere que você execute isso para desassociar um arquivo. (Veja Unstaging a Staged File para mais sobre isso.)

Poderíamos facilmente não deixar o Git assumir que queríamos dizer "extrair os dados do HEAD" especificando um commit específico para extrair a versão do arquivo. Nós apenas executaríamos algo como [git reset eb43bf file.txt].



                          [  figure -151 - redefinir caminho3]


Isso efetivamente faz a mesma coisa, como se tivéssemos revertido o conteúdo do arquivo para v1 no diretório de trabalho, rodado git addnele e revertido novamente para a v3 (sem realmente passar por todas essas etapas). Se corrermos git commit agora, ele irá gravar uma alteração que reverte esse arquivo de volta para v1 , mesmo que nunca tenhamos tido isso de novo em nosso diretório de trabalho.

Também é interessante notar que git add, como , o resetcomando aceitará uma --patchopção para desassociar o conteúdo em uma base de pedaço a pedaço. Então você pode seletivamente desarmar ou reverter o conteúdo.

(Squashing)
Vejamos como fazer algo interessante com esse novo poder - cometer commits.

Digamos que você tenha uma série de commits com mensagens como "oops", "WIP" e "esqueceu este arquivo". Você pode usar resetpara rapidamente e facilmente esmagá-los em um único commit que faz você parecer realmente inteligente. ( Squashing Commits mostra outra maneira de fazer isso, mas neste exemplo é mais simples de usar reset.)

Digamos que você tenha um projeto em que o primeiro commit tenha um arquivo, o segundo commit tenha adicionado um novo arquivo e alterado o primeiro, e o terceiro commit tenha alterado o primeiro arquivo novamente. O segundo commit foi um trabalho em andamento e você quer reduzi-lo.


        
                          [  figure -152 - redefinir squash r1]


Você pode executar git reset --soft HEAD~2para mover a ramificação HEAD de volta para uma confirmação mais antiga (a confirmação mais recente que deseja manter):

 

                            
                            [  figure -153 - redefinir squash r2]



E então simplesmente execute git commit novamente:


                            [  figure -154 - redefinir squash r3]


Agora você pode ver que seu histórico alcançável, o histórico que você empurraria, agora parece que você tinha um commit com file-a.txtv1, então um segundo que ambos modificaram file-a.txtpara v3 e foram adicionados file-b.txt. A confirmação com a versão v2 do arquivo não está mais no histórico.

(Confira)
Finalmente, você pode se perguntar qual é a diferença entre checkoute reseté. Como reset, checkoutmanipula as três árvores, e é um pouco diferente dependendo se você dá ao comando um caminho de arquivo ou não.

(Sem caminhos)
Correr [git checkout [branch]] é bem parecido com a corrida [git reset --hard [branch]], pois atualiza todas as três árvores para você parecer [branch], mas existem duas diferenças importantes.

Primeiro, ao contrário [reset --hard], o checkout diretório de trabalho é seguro; ele irá verificar se não está removendo arquivos que tenham alterações neles. Na verdade, é um pouco mais inteligente do que isso - ele tenta fazer uma mesclagem trivial no diretório de trabalho, então todos os arquivos que você não alterou serão atualizados. [reset --hard] Por outro lado, irá simplesmente substituir tudo através da placa sem verificar.

A segunda diferença importante é como as checkoutatualizações HEAD. Considerando que resetirá mover o ramo que HEAD aponta, checkoutirá mover a própria cabeça para apontar para outro ramo.

Por exemplo, digamos que temos [master] e [develop] ramificações que apontam para diferentes commits, e estamos atualmente em develop(então HEAD aponta para isso). Se corrermos git reset master, develop ele mesmo apontará para o mesmo commit que masterfaz. Se, em vez disso git checkout master, executarmos , develop não nos movermos, o próprio HEAD o faz. A cabeça agora apontará para master.

Então, em ambos os casos, estamos movendo o HEAD para apontar para commitar A, mas como fazemos isso é muito diferente. resetirá mover os pontos HEAD do ramo para, checkoutmove o próprio HEAD.

                    

                            [  figure -155 - redefinir checkout]


(Com caminhos)
A outra maneira de executar checkout é com um caminho de arquivo, que, como reset, não move HEAD. É como se [git reset [branch] file] ele atualiza-se o índice com aquele arquivo naquele commit, mas também sobrescreve o arquivo no diretório de trabalho. Seria exatamente como [git reset --hard [branch] file] (se reset deixasse você executar isso) - não é um diretório de trabalho seguro, e ele não move o HEAD.

Além disso, como git resete git add, checkoutaceitará uma --patchopção para permitir que você reverta seletivamente o conteúdo do arquivo em uma base de pedaço a pedaço.

(Resumo)
Espero que agora você entenda e se sinta mais confortável com o reset comando, mas provavelmente ainda está um pouco confuso sobre como exatamente ele difere checkout e não poderia se lembrar de todas as regras das diferentes invocações.

Aqui está uma folha de dicas para quais comandos afetam quais árvores. A coluna “HEAD” indica “REF” se esse comando mover a referência (ramificação) para a qual HEAD aponta, e “HEAD” se ele se mover para a HEAD. Preste atenção especial ao WD Safe? coluna - se disser NÃO , tire um segundo para pensar antes de executar o comando.



Nível de Confirmação              | HEAD	         | Index	        | Workdir	        | WD Safe?
-----------------------------------------------------------------------------------------------------

reset --soft [commit]               REF                NÃO                NÃO                   SIM

reset [commit]                      REF                SIM                NÃO                   SIM 

reset --hard [commit]               REF                SIM                SIM                   NÃO

checkout <commit>                   HEAD               SIM                SIM                   SIM


Nível de arquivo
-------------------------------------------------------------------------------------------------------

reset [commit] <paths>              NÃO                SIM                NÃO                   SIM

checkout [commit] <paths>           NÃO                SIM                SIM                   NÃO


7.8 Git Tools - Fusão Avançada

*Fusão Avançada
A fusão no Git é normalmente bastante fácil. Como o Git facilita a fusão de outro ramo várias vezes, isso significa que você pode ter um ramo muito longo, mas pode mantê-lo atualizado enquanto resolve pequenos conflitos com freqüência, em vez de se surpreender com um enorme conflito na região. fim da série.

No entanto, às vezes, conflitos complicados ocorrem. Ao contrário de outros sistemas de controle de versão, o Git não tenta ser excessivamente inteligente em relação à resolução de conflitos de mesclagem. A filosofia do Git é ser inteligente ao determinar quando uma resolução de mesclagem é inequívoca, mas se houver um conflito, ele não tenta ser esperto em resolvê-lo automaticamente. Portanto, se você esperar muito tempo para mesclar dois ramos que divergem rapidamente, poderá encontrar alguns problemas.

Nesta seção, veremos alguns desses problemas e quais ferramentas o Git fornece para ajudar a lidar com essas situações mais complicadas. Também abordaremos alguns tipos de fusões diferentes e não padrão que você pode fazer, além de ver como fazer o backup das mesclagens que você fez.

(Mesclar Conflitos)
Embora tenhamos abordado algumas noções básicas sobre como resolver conflitos de mesclagem em Conflitos Básicos de Mesclagem , para conflitos mais complexos, o Git fornece algumas ferramentas para ajudá-lo a descobrir o que está acontecendo e como lidar melhor com o conflito.

Primeiro de tudo, se possível, tente certificar-se de que seu diretório de trabalho esteja limpo antes de fazer uma mesclagem que possa ter conflitos. Se você tiver trabalho em andamento, envie-o para um ramo temporário ou armazene-o. Isso faz com que você possa desfazer qualquer coisa que você tente aqui. Se você tiver alterações não salvas em seu diretório de trabalho quando tentar uma mesclagem, algumas dessas dicas podem ajudá-lo a perder esse trabalho.

Vamos percorrer um exemplo muito simples. Nós temos um arquivo Ruby super simples que imprime o Hello World .

#! /usr/bin/env ruby

def hello
    puts 'hello world'
end

hello()

Em nosso repositório, criamos uma nova ramificação chamada [whitespace] e procedemos para alterar todos os terminais de linha Unix para os finais de linha do DOS, essencialmente alterando cada linha do arquivo, mas apenas com espaços em branco. Então mudamos a linha “olá mundo” para “olá mundo”.

$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'converted hello.rb to DOS'
[whitespace 3270f76] converted hello.rb to DOS
    1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
    #! /usr/bin/env ruby

    def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
    end

    hello()

$ git commit -am 'hello mundo change'
[whitespace 6d338d2] hello mundo change
    1 file changed, 1 insertion(+), 1 deletion(-)

Agora voltamos para nossa master filial e adicionamos alguma documentação para a função.

$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
    #! /usr/bin/env ruby

+# prints out a greeting
    def hello
    puts 'hello world'
    end

$ git commit -am 'document the function'
[master bec6336] document the function
    1 file changed, 1 insertion(+)

Agora tentamos nos fundir em nosso whitespace ramo e obteremos conflitos por causa das mudanças de espaço em branco.

$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
Abortando uma mesclagem
Agora temos algumas opções. Primeiro, vamos cobrir como sair dessa situação. Se você talvez não estivesse esperando conflitos e não quisesse lidar com a situação ainda, você pode simplesmente desistir da fusão com git merge --abort.

$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master

A [git merge --abort] opção tenta voltar ao seu estado antes de executar a mesclagem. Os únicos casos em que pode não ser possível fazer isso perfeitamente seria se você tivesse alterações não armazenadas, não confirmadas em seu diretório de trabalho quando você executou, caso contrário, ele deve funcionar bem.

Se por algum motivo você quiser apenas começar de novo, você também pode executar [git reset --hard HEAD], e seu repositório estará de volta ao último estado comprometido. Lembre-se de que qualquer trabalho não confirmado será perdido, por isso, certifique-se de não querer nenhuma das suas alterações.



(Ignorando o espaço em branco)
Neste caso específico, os conflitos são relacionados a espaço em branco. Sabemos disso porque o caso é simples, mas também é fácil dizer em casos reais quando se olha para o conflito, porque cada linha é removida de um lado e adicionada novamente no outro. Por padrão, o Git considera todas essas linhas como alteradas, portanto, não é possível mesclar os arquivos.

A estratégia de mesclagem padrão pode receber argumentos, e alguns deles ignoram adequadamente as alterações de espaço em branco. Se você perceber que há muitos problemas de espaço em branco em uma mesclagem, basta abortar e fazer novamente, desta vez com -Xignore-all-spaceou [-Xignore-space-change]. A primeira opção ignora completamente os espaços em branco ao comparar as linhas, a segunda trata as seqüências de um ou mais caracteres em branco como equivalentes.

$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
    hello.rb | 2 +-
    1 file changed, 1 insertion(+), 1 deletion(-)

Como neste caso, as alterações reais do arquivo não foram conflitantes, uma vez que ignoramos as alterações de espaço em branco, tudo se funde muito bem.

Este é um salva-vidas, se você tem alguém em sua equipe que gosta de reformatá-lo ocasionalmente de espaços para guias ou vice-versa.


(Re-fundição de arquivo manual)
Embora o Git manipule muito bem o pré-processamento de espaços em branco, existem outros tipos de mudanças que talvez o Git não possa manipular automaticamente, mas que são correções de script. Como exemplo, vamos fingir que o Git não conseguiu lidar com a mudança de espaço em branco e precisávamos fazer isso manualmente.

O que realmente precisamos fazer é executar o arquivo que estamos tentando mesclar através de um dos2unix programa antes de tentar a mesclagem de arquivos real. Então, como faríamos isso?

Primeiro, entramos no estado de conflito de mesclagem. Então, queremos obter cópias da minha versão do arquivo, sua versão (do ramo em que estamos mesclando) e a versão comum (de onde ambos os lados se ramificaram). Então, queremos corrigir o lado deles ou do lado e tentar novamente a mesclagem apenas para esse arquivo único.

Obtendo as três versões de arquivos é realmente muito fácil. O Git armazena todas essas versões no índice em “estágios”, no qual cada um possui números associados a eles. O estágio 1 é o ancestral comum, o estágio 2 é sua versão e o estágio 3 é da MERGE_HEADversão em que você está se fundindo (“deles”).

Você pode extrair uma cópia de cada uma dessas versões do arquivo em conflito com o git showcomando e uma sintaxe especial.

$ git show :1:hello.rb > hello.common.rb
$ git show :2:hello.rb > hello.ours.rb
$ git show :3:hello.rb > hello.theirs.rb

Se você quiser obter um pouco mais de hard core, você também pode usar o [ls-files -u] comando de encanamento para obter os SHA-1s reais dos Git blobs para cada um desses arquivos.

$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb

O [:1:hello.rb] é apenas um atalho para procurar o blob SHA-1.

Agora que temos o conteúdo de todos os três estágios em nosso diretório de trabalho, podemos corrigir manualmente o deles para corrigir o problema de espaço em branco e mesclar o arquivo com o [git merge-file] comando pouco conhecido que faz exatamente isso.

$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
    #! /usr/bin/env ruby

    +# prints out a greeting
    def hello
-   puts 'hello world'
+   puts 'hello mundo'
    end

    hello()

Neste ponto, combinamos bem o arquivo. Na verdade, isso funciona melhor que a [ignore-space-change] opção, porque isso corrige as alterações de espaço em branco antes de mesclar, em vez de simplesmente ignorá-las. Na ignore-space-change fusão, acabamos com algumas linhas com finais de linha do DOS, tornando as coisas mescladas.

Se você quiser ter uma idéia antes de finalizar este commit sobre o que realmente foi alterado entre um lado ou outro, você pode pedir [git diff] para comparar o que está em seu diretório de trabalho que você está prestes a cometer como resultado da fusão de qualquer um dos esses estágios. Vamos passar por todos eles.

Para comparar seu resultado com o que você tinha em seu ramo antes da fusão, em outras palavras, para ver o que a mesclagem introduzia, você pode executar [git diff --ours]

$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

    # prints out a greeting
    def hello
-  puts 'hello world'
+  puts 'hello mundo'
    end

    hello()

Então, aqui podemos ver facilmente que o que aconteceu em nossa ramificação, o que estamos realmente introduzindo nesse arquivo com essa mesclagem, está mudando essa linha única.

Se quisermos ver como o resultado da mesclagem diferia do que estava do lado deles, você pode correr [git diff --theirs]. Neste e no exemplo a seguir, temos que usar -bpara remover o espaço em branco porque estamos comparando com o que está no Git, não com o nosso [hello.theirs.rb] arquivo limpo .

$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
    #! /usr/bin/env ruby

+# prints out a greeting
    def hello
    puts 'hello mundo'
    end

Finalmente, você pode ver como o arquivo mudou de ambos os lados com [git diff --base].

$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
    #! /usr/bin/env ruby

+# prints out a greeting
    def hello
-  puts 'hello world'
+  puts 'hello mundo'
    end

    hello()

Neste ponto, podemos usar o [git clean] comando para limpar os arquivos extras que criamos para fazer a mesclagem manual, mas não precisamos mais.

$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb


(Verificando Conflitos)
Talvez não estejamos satisfeitos com a resolução neste ponto por algum motivo, ou talvez a edição manual de um ou ambos os lados ainda não funcionou bem e precisamos de mais contexto.

Vamos mudar o exemplo um pouco. Para este exemplo, temos dois ramos mais antigos que cada um deles tem alguns commits, mas criam um conflito de conteúdo legítimo quando mesclados.

$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code

Agora temos três commits únicos que vivem apenas no master branch e outros três que vivem no mundo branch. Se tentarmos fundir o mundo ramo, teremos um conflito.

$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
Gostaríamos de ver qual é o conflito de mesclagem. Se abrirmos o arquivo, veremos algo assim:

#! /usr/bin/env ruby

def hello
<<<<<<< HEAD
    puts 'hola world'
=======
    puts 'hello mundo'
>>>>>>> mundo
end

hello()

Os dois lados da mesclagem adicionaram conteúdo a esse arquivo, mas alguns dos commits modificaram o arquivo no mesmo local que causou esse conflito.

Vamos explorar algumas ferramentas que você tem à sua disposição para determinar como esse conflito surgiu. Talvez não seja óbvio exatamente como você deve corrigir esse conflito. Você precisa de mais contexto.

Uma ferramenta útil é [git checkout] com a opção '--conflict'. Isso irá verificar novamente o arquivo novamente e substituir os marcadores de conflito de mesclagem. Isso pode ser útil se você quiser redefinir os marcadores e tentar resolvê-los novamente.

Você pode passar [--conflict] tanto [diff3] ou [merge](o que é o padrão). Se você passar diff3, o Git usará uma versão um pouco diferente dos marcadores de conflito, não apenas fornecendo as versões "nossa" e "deles", mas também a versão "base" inline para fornecer mais contexto.

$ git checkout --conflict=diff3 hello.rb
Assim que executamos isso, o arquivo ficará assim:

#! /usr/bin/env ruby

def hello
<<<<<<< ours
    puts 'hola world'
||||||| base
    puts 'hello world'
=======
    puts 'hello mundo'
>>>>>>> theirs
end

hello()

Se você gosta deste formato, você pode configurá-lo como padrão para futuros conflitos de mesclagem definindo a [merge.conflictstyle] configuração como diff3.

$ git config --global merge.conflictstyle diff3

O [git checkout] comando também pode tomar [--our] se [--theirs] opções, que podem ser uma maneira muito rápida de apenas escolher um lado ou o outro sem fundir coisas em tudo.

Isso pode ser particularmente útil para conflitos de arquivos binários onde você pode simplesmente escolher um lado, ou onde você quer apenas mesclar certos arquivos de outro branch - você pode fazer a mesclagem e então verificar certos arquivos de um lado ou de outro antes de confirmar .



(Mesclar Log)
Outra ferramenta útil ao resolver conflitos de mesclagem é [git log]. Isso pode ajudá-lo a contextualizar o que pode ter contribuído para os conflitos. Revisar um pouco da história para lembrar por que duas linhas de desenvolvimento estavam tocando a mesma área de código pode ser realmente útil às vezes.

Para obter uma lista completa de todos os commits exclusivos que foram incluídos em qualquer ramificação envolvida nessa mesclagem, podemos usar a sintaxe de "ponto triplo" que aprendemos no Ponto Triplo .

$ git log --oneline --left-right HEAD...MERGE_HEAD
< f1270f7 update README
< 9af9d3b add a README
< 694971d update phrase to hola world
> e3eb223 add more tests
> 7cff591 add testing script
> c3ffff1 changed text to hello mundo


Essa é uma boa lista dos seis commits totais envolvidos, bem como em qual linha de desenvolvimento cada commit estava.

Podemos simplificar ainda mais isso, para nos dar um contexto muito mais específico. Se adicionarmos a [--merge] opção [git log], ela só mostrará as confirmações em qualquer lado da mesclagem que toca em um arquivo que está em conflito no momento.

$ git log --oneline --left-right --merge
< 694971d update phrase to hola world
> c3ffff1 changed text to hello mundo

Se você executar isso com a [-p] opção, você terá apenas os diffs para o arquivo que acabou em conflito. Isso pode ser muito útil para fornecer rapidamente o contexto necessário para ajudar a entender por que algo está em conflito e como resolvê-lo de maneira mais inteligente.

(Formato de Difusão Combinado)
Como o Git organiza os resultados de mesclagem que são bem-sucedidos, quando você executa [git diff] em um estado de mesclagem conflitante, só obtém o que ainda está em conflito. Isso pode ser útil para ver o que você ainda precisa resolver.

Quando você executar [git diff] diretamente após um conflito de mesclagem, ele fornecerá informações em um formato de saída diff exclusivo.

$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
    #! /usr/bin/env ruby

    def hello
++<<<<<<< HEAD
    +  puts 'hola world'
++=======
+   puts 'hello mundo'
++>>>>>>> mundo
    end

    hello()

O formato é chamado de "Combined Diff" e fornece duas colunas de dados ao lado de cada linha. A primeira coluna mostra se essa linha é diferente (adicionada ou removida) entre a ramificação "ours" e o arquivo em seu diretório de trabalho e a segunda coluna faz o mesmo entre a ramificação "theirs" e a cópia do diretório de trabalho.

Portanto, nesse exemplo, você pode ver que as linhas <<<<<<<e >>>>>>>estão na cópia de trabalho, mas não estavam em nenhum lado da mesclagem. Isso faz sentido porque a ferramenta de mesclagem os colocou lá para o nosso contexto, mas esperamos removê-los.

Se resolvermos o conflito e corrermos git diffnovamente, veremos a mesma coisa, mas é um pouco mais útil.

$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
    #! /usr/bin/env ruby

    def hello
-   puts 'hola world'
    -  puts 'hello mundo'
++  puts 'hola mundo'
    end

    hello()

Isso nos mostra que o “mundo hola” estava do nosso lado, mas não na cópia de trabalho, que “olá mundo” estava do lado deles, mas não na cópia de trabalho e, finalmente, que “hola mundo” não estava em nenhum dos lados, mas agora a cópia de trabalho. Isso pode ser útil para revisar antes de confirmar a resolução.

Você também pode obter isso de [git log] qualquer mesclagem para ver como algo foi resolvido após o fato. O Git produzirá este formato se você executar [git show] uma consolidação de mesclagem, ou se você adicionar uma [--cc] opção a um [git log -p] (que, por padrão, só mostra correções para commits não mesclados).

$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
    #! /usr/bin/env ruby

    def hello
-   puts 'hola world'
    -  puts 'hello mundo'
++  puts 'hola mundo'
    end

    hello()

(Desfazer mesclagens)
Agora que você sabe como criar um commit de merge, você provavelmente fará algum por engano. Uma das grandes coisas sobre o trabalho com o Git é que não há problema em cometer erros, porque é possível (e em muitos casos fácil) consertá-los.

Merge commits não são diferentes. Digamos que você tenha começado a trabalhar em uma ramificação de tópicos, acidentalmente mesclado master e agora seu histórico de commits se parece com isto:



                            [Figura 156. Confirmação de mesclagem acidental]



Existem duas maneiras de abordar esse problema, dependendo do resultado desejado.

(Corrigir as referências)
Se a consolidação de mesclagem indesejada só existir em seu repositório local, a solução mais fácil e melhor é mover as ramificações para que elas apontem para onde você deseja. Na maioria dos casos, se você seguir o errante [git merge] com [git reset --hard HEAD~], isso irá repor os ponteiros do ramo para que eles fiquem assim:




                            [Figura 157. História após git reset --hard HEAD~]



Nós abordamos resetnovamente em Reset Demystified , então não deve ser muito difícil descobrir o que está acontecendo aqui. Aqui está uma atualização rápida: [reset --hard] geralmente passa por três etapas:

1. Mova os pontos HEAD da ramificação para. Neste caso, queremos mover masterpara onde estava antes do merge commit ( C6).
2. Faça o índice parecer com o HEAD.
3. Torne o diretório de trabalho parecido com o índice.

A desvantagem dessa abordagem é que ela está reescrevendo o histórico, o que pode ser problemático com um repositório compartilhado. Confira os perigos de Rebasing para mais sobre o que pode acontecer; a versão curta é que, se outras pessoas tiverem os commits que você está reescrevendo, você provavelmente deve evitar reset. Essa abordagem também não funcionará se qualquer outra confirmação tiver sido criada desde a fusão; mover os árbitros perderia efetivamente essas mudanças.

(Reverter o commit)
Se mover os ponteiros do ramo não funcionar, o Git lhe dá a opção de fazer um novo commit que desfaz todas as mudanças de um já existente. O Git chama essa operação de "reverter" e, nesse cenário específico, você a invocaria assim:

$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"

O [-m 1] sinalizador indica qual pai é a “linha principal” e deve ser mantido. Quando você invoca uma mesclagem em HEAD( git merge topic), o novo commit tem dois pais: o primeiro é HEAD( C6), e o segundo é a ponta do branch que está sendo mesclado ( C4). Nesse caso, queremos desfazer todas as alterações introduzidas pela mesclagem no pai # 2 ( C4), mantendo todo o conteúdo do pai # 1 ( C6).

O histórico com o revert commit é assim:



                            [Figura 158. História após git revert -m 1]



O novo commit [^M] tem exatamente o mesmo conteúdo C6, então a partir daqui é como se a mesclagem nunca tivesse acontecido, exceto que os commits agora não consolidados ainda estão no HEAD histórico. Git vai ficar confuso se você tentar mesclar topicem master novamente:

$ git merge topic
Already up-to-date.

Não há nada topic nisso que já não possa ser alcançado master. O que é pior, se você adicionar o trabalho [topic] e mesclar novamente, o Git só trará as alterações desde a fusão revertida:




                            [Figura 159. Histórico com uma mesclagem incorreta]



A melhor maneira de contornar isso é reverter a mesclagem original, pois agora você deseja inserir as alterações que foram revertidas e criar uma nova consolidação de mesclagem:

$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic




                        [Figura 160. Histórico após a fusão de uma mesclagem revertida]



Neste exemplo, Me [^M] cancele. [^^M] efetivamente funde-se nas alterações de C3e C4, e C8mescla nas alterações C7, portanto, agora topicé totalmente mesclada.

(Outros tipos de fusões)
Até agora, cobrimos a mesclagem normal de duas ramificações, normalmente tratadas com o que é chamado de estratégia "recursiva" de fusão. Existem outras maneiras de mesclar ramos no entanto. Vamos cobrir alguns deles rapidamente.

(Nossa ou a sua preferência)
Primeiro de tudo, há outra coisa útil que podemos fazer com o modo “recursivo” normal de mesclagem. Nós já vimos o [ignore-all-space] e as [ignore-space-chang] eopções que são passadas com um, [-X] mas também podemos dizer ao Git para favorecer um lado ou outro quando ele vê um conflito.

Por padrão, quando o Git vê um conflito entre duas ramificações sendo mescladas, ele adicionará marcadores de conflito de mesclagem ao seu código e marcará o arquivo como em conflito e permitirá que você o resolva. Se você preferir que o Git simplesmente escolha um lado específico e ignore o outro lado, em vez de permitir que você solucione manualmente o conflito, você pode passar o merge comando a [-Xours] ou [-Xtheirs].

Se o Git vir isso, ele não adicionará marcadores de conflito. Quaisquer diferenças que sejam mescláveis, serão mescladas. Quaisquer diferenças que conflitem, ele simplesmente escolherá o lado que você especificar no todo, incluindo arquivos binários.

Se voltarmos ao exemplo do “hello world” que estávamos usando antes, podemos ver que a fusão em nosso ramo causa conflitos.

$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.

No entanto, se corremos com -Xours ou -Xtheirs não.

$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
    hello.rb | 2 +-
    test.sh  | 2 ++
    2 files changed, 3 insertions(+), 1 deletion(-)
    create mode 100644 test.sh

Nesse caso, em vez de obter marcadores de conflito no arquivo com “hello mundo” de um lado e “hola world” no outro, ele simplesmente escolherá “hola world”. No entanto, todas as outras alterações não conflitantes nesse ramo são mescladas com êxito.

Essa opção também pode ser passada para o [git merge-file] comando que vimos anteriormente executando algo como [git merge-file --ours] para mesclagens de arquivos individuais.

Se você quer fazer algo assim, mas não tem o Git tentando mesclar mudanças do outro lado, existe uma opção mais draconiana, que é a estratégia de mesclagem “nossa” . Isso é diferente da opção de mesclagem recursiva "our" .

Isso basicamente fará uma fusão falsa. Ele irá gravar uma nova consolidação de mesclagem com ambas as ramificações como pais, mas nem sequer olhará para a ramificação na qual você está mesclando. Ela simplesmente registrará como resultado da mesclagem o código exato na sua ramificação atual.

$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$

Você pode ver que não há diferença entre o ramo em que estávamos e o resultado da mesclagem.

Isso pode ser útil, basicamente, para enganar o Git e pensar que uma ramificação já está mesclada ao fazer uma fusão mais tarde. Por exemplo, digamos que você tenha se ramificado de uma release ramificação e tenha feito algum trabalho nela que você queira mesclar em sua master filial em algum momento. Enquanto isso, alguma correção de bugs master precisa ser backportada para o seu release branch. Você pode mesclar a ramificação bugfix na release ramificação e também [merge -s ours] a mesma ramificação em sua master ramificação (mesmo que a correção já esteja lá), então quando você mesclar a release ramificação mais tarde novamente, não haverá conflitos da correção da falha.

(Fusão da subárvore)
A idéia da mesclagem da subárvore é que você tem dois projetos e um dos projetos mapeia para um subdiretório do outro. Quando você especifica uma mesclagem de subárvore, o Git é geralmente inteligente o bastante para descobrir que uma é uma subárvore da outra e se fundir apropriadamente.

Vamos passar por um exemplo de adicionar um projeto separado em um projeto existente e, em seguida, mesclar o código do segundo em um subdiretório do primeiro.

Primeiro, vamos adicionar o aplicativo Rack ao nosso projeto. Vamos adicionar o projeto Rack como uma referência remota em nosso próprio projeto e depois verificá-lo em sua própria ramificação:

$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
    * [new branch]      build      -> rack_remote/build
    * [new branch]      master     -> rack_remote/master
    * [new branch]      rack-0.4   -> rack_remote/rack-0.4
    * [new branch]      rack-0.9   -> rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"

Agora temos a raiz do projeto Rack em nossa rack_branchfilial e nosso próprio projeto na masterfilial. Se você verificar um e depois o outro, verá que eles têm raízes de projeto diferentes:

$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README

Este é um conceito meio estranho. Nem todas as ramificações em seu repositório precisam ser ramificações do mesmo projeto. Não é comum, porque raramente é útil, mas é bastante fácil ter ramificações contendo histórias completamente diferentes.

Neste caso, queremos colocar o projeto Rack em nosso master projeto como um subdiretório. Nós podemos fazer isso no Git com [git read-tree]. Você aprenderá mais sobre read-treee seus amigos no Git Internals , mas por enquanto saberá que ele lê a árvore raiz de um branch em sua área de preparação atual e diretório de trabalho. Acabamos de voltar para a sua master filial e puxamos a [rack_branch] filial para o [rack] subdiretório da nossa master filial do nosso projeto principal:

$ git read-tree --prefix=rack/ -u rack_branch

Quando nos comprometemos, parece que temos todos os arquivos do Rack sob esse subdiretório - como se tivéssemos copiado de um tarball. O que é interessante é que podemos facilmente mesclar as mudanças de um dos ramos para o outro. Portanto, se o projeto do Rack for atualizado, poderemos extrair alterações de envio alternando para esse ramo e puxando:

$ git checkout rack_branch
$ git pull

Então, podemos mesclar essas alterações de volta ao nosso masterramo. Para extrair as alterações e preencher a mensagem de confirmação, use a --squashopção, bem como a -Xsubtreeopção da estratégia de mesclagem recursiva . (A estratégia recursiva é o padrão aqui, mas nós a incluímos para maior clareza.)

$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested
Todas as alterações do projeto Rack são mescladas e prontas para serem confirmadas localmente. Você também pode fazer o oposto - fazer alterações no racksubdiretório de sua ramificação mestre e, em seguida, mesclá-las na sua rack_branch filial posteriormente para enviá-las aos mantenedores ou empurrá-las para o fluxo ascendente.

Isso nos dá uma maneira de ter um fluxo de trabalho um pouco semelhante ao fluxo de trabalho do submódulo sem usar submódulos (que abordaremos em Submódulos ). Podemos manter filiais com outros projetos relacionados em nosso repositório e subárvore mesclá-los em nosso projeto ocasionalmente. É bom em alguns aspectos, por exemplo, todo o código está comprometido com um único lugar. No entanto, ele tem outras desvantagens, pois é um pouco mais complexo e mais fácil cometer erros ao reintegrar as alterações ou ao enviar acidentalmente uma ramificação para um repositório não relacionado.

Outra coisa um pouco estranha é que para obter uma diferença entre o que você tem em seu [rack] subdiretório e o código em seu [rack_branch] branch - para ver se você precisa mesclá-los - você não pode usar o diff comando normal . Em vez disso, você deve executar [git diff-tree] com o ramo que você deseja comparar:

$ git diff-tree -p rack_branch

Ou, para comparar o que está em seu racksubdiretório com o que a masterfilial no servidor foi a última vez que você buscou, você pode executar

$ git diff-tree -p rack_remote/master

7.9 [[ Ferramentas Git - Rerere ]] 

*Rerere
A [git rerere] funcionalidade é um pouco oculta. O nome significa “reusar resolução gravada” e, como o nome sugere, permite que você peça ao Git para lembrar como você resolveu um conflito, de modo que da próxima vez que ele vir o mesmo conflito, o Git possa resolvê-lo automaticamente.

Há vários cenários nos quais essa funcionalidade pode ser realmente útil. Um dos exemplos mencionados na documentação é se você quiser ter certeza de que uma ramificação de tópico de longa duração será mesclada de forma limpa, mas não deseja ter várias confirmações de mesclagem intermediárias. Com a opção rerereativada, você pode mesclar ocasionalmente, resolver os conflitos e, em seguida, desfazer a mesclagem. Se você fizer isso continuamente, então a mesclagem final deve ser fácil, porque rererepode fazer tudo para você automaticamente.

Essa mesma tática pode ser usada se você quiser manter uma ramificação rebaixada para não ter que lidar com os mesmos conflitos de rebasing sempre que fizer isso. Ou se você quiser pegar uma ramificação que você mesclou e corrigiu um monte de conflitos e, em seguida, decidir rebase em vez disso - você provavelmente não terá que fazer todos os mesmos conflitos novamente.

Outra situação é onde você mescla um monte de ramos de tópicos em evolução juntos em uma cabeça testável ocasionalmente, como o próprio projeto Git faz. Se os testes falharem, você poderá retroceder as mesclagens e refazê-las sem a ramificação do tópico que fez os testes falharem sem precisar resolver novamente os conflitos.

Para habilitar a [rerere] funcionalidade, basta executar esta configuração:

$ git config --global rerere.enabled true

Você também pode ativá-lo criando o [.git/rr-cache] diretório em um repositório específico, mas a configuração é mais clara e pode ser feita globalmente.

Agora vamos ver um exemplo simples, semelhante ao nosso anterior. Digamos que temos um arquivo com o seguinte nome hello.rb:

#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

Em um ramo nós mudamos a palavra “olá” para “hola”, então em outro ramo nós mudamos o “mundo” para o “mundo”, como antes.

                                [figure - 161 - rerere]                        


Quando mesclarmos os dois ramos juntos, obteremos um conflito de mesclagem:

$ git merge i18n-world
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Recorded preimage for 'hello.rb'
Automatic merge failed; fix conflicts and then commit the result.

Você deve notar a nova linha [Recorded preimage for FILE] lá. Caso contrário, deve parecer exatamente como um conflito de mesclagem normal. Neste ponto, rererepode nos dizer algumas coisas. Normalmente, você pode executar git statusneste momento para ver o que está em conflito:

$ git status
# On branch master
# Unmerged paths:
#   (use "git reset HEAD <file>..." to unstage)
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      hello.rb
#

No entanto, [git rerere] também informará com o que registrou o estado de pré-mesclagem [git rerere status]:

$ git rerere status
hello.rb

E [git rerere diff] mostrará o estado atual da resolução - o que você começou a resolver e o que resolveu.

$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,11 @@
 #! /usr/bin/env ruby

 def hello
-<<<<<<<
-  puts 'hello mundo'
-=======
+<<<<<<< HEAD
   puts 'hola world'
->>>>>>>
+=======
+  puts 'hello mundo'
+>>>>>>> i18n-world
 end

Além disso (e isso não está realmente relacionado a rerere), você pode usar [ls-files -u] para ver os arquivos em conflito e as versões antes, esquerda e direita:

$ git ls-files -u
100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1	hello.rb
100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2	hello.rb
100644 54336ba847c3758ab604876419607e9443848474 3	hello.rb

Agora você pode resolvê-lo para ser apenas puts 'hola mundo'e você pode executar o [rerere diff] comando novamente para ver o que rerere vai lembrar:

$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-<<<<<<<
-  puts 'hello mundo'
-=======
-  puts 'hola world'
->>>>>>>
+  puts 'hola mundo'
 end

Então, isso basicamente diz, quando Git vê um grande conflito em um hello.rb arquivo que tem “hello mundo” de um lado e “hola world” do outro, ele irá resolvê-lo para “hola mundo”.

Agora podemos marcá-lo como resolvido e confirmá-lo:

$ git add hello.rb
$ git commit
Recorded resolution for 'hello.rb'.
[master 68e16e5] Merge branch 'i18n'
Você pode ver que "Resolução gravada para FILE".

                                     

                                    [figure-162 rerere 2]



Agora, vamos desfazer essa mesclagem e, em seguida, rebase-a em cima de nosso branch master. Podemos mover nossa ramificação de volta usando resetcomo vimos em Redefinir desmistificada .

$ git reset --hard HEAD^
HEAD is now at ad63f15 i18n the hello

Nossa fusão é desfeita. Agora vamos rebase o ramo de tópicos.

$ git checkout i18n-world
Switched to branch 'i18n-world'

$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: i18n one word
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Failed to merge in the changes.
Patch failed at 0001 i18n one word

Agora, temos o mesmo conflito de mesclagem como esperávamos, mas dê uma olhada na Resolved FILE using previous resolution linha. Se olharmos para o arquivo, veremos que ele já foi resolvido, não há marcadores de conflito de mesclagem nele.

#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end

Além disso, git diff mostrará como foi automaticamente resolvido novamente:

$ git diff
diff --cc hello.rb
index a440db6,54336ba..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end



                            [figure - 163 rerere 3]



Você também pode recriar o estado do arquivo em conflito com o checkoutcomando:

$ git checkout --conflict=merge hello.rb
$ cat hello.rb
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end

Vimos um exemplo disso na fusão avançada . Por enquanto, vamos resolver rerere novamente apenas executando novamente:

$ git rerere
Resolved 'hello.rb' using previous resolution.
$ cat hello.rb
#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end

Resolvemos o arquivo automaticamente usando a rerere resolução em cache. Agora você pode adicionar e continuar o rebase para concluí-lo.

$ git add hello.rb
$ git rebase --continue
Applying: i18n one word
Portanto, se você fizer muitas mesclagens ou quiser manter um branch de tópicos atualizado com sua ramificação master sem uma tonelada de mesclagens ou se fizer um rebase com frequência, poderá ativar rerere a sua vida um pouco.


7.10 [[ Git Tools - Depurando com o Git ]]

*Depurando com o Git
O Git também fornece algumas ferramentas para ajudá-lo a depurar problemas em seus projetos. Como o Git é projetado para funcionar com praticamente qualquer tipo de projeto, essas ferramentas são bem genéricas, mas geralmente podem ajudá-lo a procurar um bug ou culpado quando as coisas dão errado.

(Anotação de arquivo)
Se você rastrear um bug em seu código e quiser saber quando ele foi introduzido e por quê, a anotação de arquivo geralmente é sua melhor ferramenta. Ele mostra a você qual commit foi o último a modificar cada linha de qualquer arquivo. Então, se você ver que um método no seu código é defeituoso, você pode anotar o arquivo com [git blame]para ver quando cada linha do método foi editada pela última vez e por quem. Este exemplo usa a [-L ] opção para limitar a saída às linhas 12 a 22:

$ git blame -L 12,22 simplegit.rb
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = 'master')
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command("git show #{tree}")
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = 'master')
79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command("git log #{tree}")
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command("git blame #{path}")
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end

Observe que o primeiro campo é o SHA-1 parcial da confirmação que modificou a última linha. Os próximos dois campos são valores extraídos desse commit - o nome do autor e a data de autoria desse commit - para que você possa ver facilmente quem modificou essa linha e quando. Depois disso vem o número da linha e o conteúdo do arquivo. Observe também as [^4832fe2] linhas de confirmação, que designam que essas linhas estavam no commit original desse arquivo. Esse commit é quando este arquivo foi adicionado pela primeira vez a este projeto, e essas linhas permanecem inalteradas desde então. Isso é um pouco confuso, porque agora você já viu pelo menos três maneiras diferentes que o Git usa [^] para modificar um commit SHA-1, mas é isso que significa aqui.

Outra coisa legal sobre o Git é que ele não rastreia renominações de arquivos explicitamente. Ele registra os instantâneos e, em seguida, tenta descobrir o que foi renomeado implicitamente, após o fato. Uma das características interessantes disso é que você pode pedir para descobrir todos os tipos de movimento de código também. Se você passar [-C] para [git blame], o Git analisa o arquivo que você está anotando e tenta descobrir de onde os fragmentos de código originalmente vieram se fossem copiados de outro lugar. Por exemplo, digamos que você esteja refatorando um arquivo denominado [GITServerHandler.m] em vários arquivos, um deles é [GITPackUpload.m]. Culpando [GITPackUpload.m] com a [-C] opção, você pode ver de onde as seções do código vieram originalmente:

$ git blame -C -L 141,153 GITPackUpload.m
f344f58d GITServerHandler.m (Scott 2009-01-04 141)
f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC
f344f58d GITServerHandler.m (Scott 2009-01-04 143) {
70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)
56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {
56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb
56ef2caf GITServerHandler.m (Scott 2009-01-05 153)

Isso é realmente útil. Normalmente, você obtém como o commit original do commit no qual você copiou o código, porque essa é a primeira vez que você tocou essas linhas nesse arquivo. O Git lhe diz o commit original onde você escreveu aquelas linhas, mesmo que fosse em outro arquivo.

(Pesquisa binária)
Anotar um arquivo ajuda se você souber onde o problema deve começar. Se você não sabe o que está quebrando, e houve dezenas ou centenas de commits desde o último estado em que você sabe que o código funcionou, é provável que você solicite [git bisect] ajuda. O bisect comando faz uma pesquisa binária através do seu histórico de commits para ajudá-lo a identificar o mais rápido possível qual commit introduziu um problema.

Digamos que você acabou de lançar uma versão do seu código para um ambiente de produção, você está recebendo relatórios de bugs sobre algo que não estava acontecendo em seu ambiente de desenvolvimento, e você não pode imaginar por que o código está fazendo isso. Você volta ao seu código, e acontece que você pode reproduzir o problema, mas não consegue descobrir o que está errado. Você pode dividir o código para descobrir. Primeiro você corre [git bisect start] para fazer as coisas acontecer, e então você usa [git bisect bad] para dizer ao sistema que o commit atual está quebrado. Então, você deve informar a divisão quando o último estado bom conhecido foi git bisect good [good_commit]:

$ git bisect start
$ git bisect bad
$ git bisect good v1.0
Bisecting: 6 revisions left to test after this
[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo

O Git descobriu que cerca de 12 commits vieram entre o commit que você marcou como o último bom commit (v1.0) e a atual versão ruim, e deu checkout no middle para você. Neste ponto, você pode executar seu teste para ver se o problema existe a partir desse commit. Em caso afirmativo, foi introduzido algum tempo antes desse commit do meio; Se isso não acontecer, o problema foi introduzido em algum momento após o commit do meio. Acontece que não há nenhum problema aqui, e você diz ao Git que digitando git bisect goode continue sua jornada:

$ git bisect good
Bisecting: 3 revisions left to test after this
[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing
Agora você está em outro commit, a meio caminho entre o que você acabou de testar e o seu commit ruim. Você executa seu teste novamente e descobre que este commit está quebrado, então você diz ao Git que [git bisect bad]:

$ git bisect bad
Bisecting: 1 revisions left to test after this
[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table

Esse commit é bom, e agora o Git tem todas as informações necessárias para determinar onde o problema foi introduzido. Ele informa o SHA-1 do primeiro commit incorreto e mostra algumas das informações de commit e quais arquivos foram modificados naquele commit, assim você pode descobrir o que aconteceu que pode ter introduzido este bug:

$ git bisect good
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
Author: PJ Hyett <pjhyett@example.com>
Date:   Tue Jan 27 14:48:32 2009 -0800

    secure this thing

:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730
f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config

Quando você terminar, você deve executar [git bisect reset] para redefinir seu HEAD para onde você estava antes de começar, ou você vai acabar em um estado estranho:

$ git bisect reset

Esta é uma ferramenta poderosa que pode ajudá-lo a verificar centenas de commits para um bug introduzido em minutos. Na verdade, se você tiver um script que sairá de 0 se o projeto for bom ou diferente de 0 se o projeto for ruim, você poderá automatizar totalmente git bisect. Primeiro, você diz novamente o escopo da divisão, fornecendo os commits ruins e bons conhecidos. Você pode fazer isso listando-os com o [bisect start] comando, se quiser, listando o commit anterior conhecido e o segundo commit válido:

$ git bisect start HEAD v1.0
$ git bisect run test-error.sh

Fazer isso é executado automaticamente test-error.shem cada confirmação de saída até que o Git encontre o primeiro commit quebrado. Você também pode executar algo como [make] ou [make test] sou o que você tem que executa testes automatizados para você.


7.11 [[ Git Tools - Submódulos ]]

*Submódulos
Muitas vezes acontece que, ao trabalhar em um projeto, você precisa usar outro projeto de dentro dele. Talvez seja uma biblioteca que um terceiro desenvolveu ou que você está desenvolvendo separadamente e usando em vários projetos principais. Um problema comum surge nesses cenários: você quer ser capaz de tratar os dois projetos como separados e ainda assim poder usar um dentro do outro.

Aqui está um exemplo. Suponha que você esteja desenvolvendo um site e criando feeds Atom. Em vez de escrever seu próprio código gerador de Atom, você decide usar uma biblioteca. É provável que você tenha que incluir esse código em uma biblioteca compartilhada, como uma instalação do CPAN ou gem do Ruby, ou copiar o código-fonte em sua própria árvore do projeto. O problema de incluir a biblioteca é que é difícil personalizar a biblioteca de qualquer maneira e, muitas vezes, é mais difícil implantá-la, porque você precisa garantir que cada cliente tenha essa biblioteca disponível. O problema de copiar o código em seu próprio projeto é que qualquer alteração personalizada feita por você é difícil de mesclar quando as alterações do upstream se tornam disponíveis.

O Git resolve esse problema usando submódulos. Submódulos permitem que você mantenha um repositório Git como um subdiretório de outro repositório Git. Isso permite clonar outro repositório em seu projeto e manter seus commits separados.

(Começando com submódulos)
Vamos percorrer o desenvolvimento de um projeto simples que foi dividido em um projeto principal e em alguns subprojetos.

Vamos começar adicionando um repositório Git existente como um submódulo do repositório em que estamos trabalhando. Para adicionar um novo submódulo, use o [git submodule add] comando com a URL absoluta ou relativa do projeto que você gostaria de iniciar o rastreamento. Neste exemplo, adicionaremos uma biblioteca chamada "DbConnector".

$ git submodule add https://github.com/chaconinc/DbConnector
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.

Por padrão, os submódulos incluirão o subprojeto em um diretório com o mesmo nome do repositório, neste caso, “DbConnector”. Você pode adicionar um caminho diferente no final do comando se quiser ir para outro lugar.

Se você correr [git status] neste momento, você notará algumas coisas.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   .gitmodules
	new file:   DbConnector

Primeiro você deve notar o novo [.gitmodules] arquivo. Este é um arquivo de configuração que armazena o mapeamento entre o URL do projeto e o subdiretório local em que você o inseriu:

[submodule "DbConnector"]
	path = DbConnector
	url = https://github.com/chaconinc/DbConnector

Se você tiver vários submódulos, terá várias entradas nesse arquivo. É importante observar que esse arquivo é controlado por versão com seus outros arquivos, como seu .gitignore arquivo. É empurrado e puxado com o resto do seu projeto. É assim que outras pessoas que clonam este projeto sabem de onde obter os projetos de submódulos.

|Nota
Como o URL no arquivo .gitmodules é o que outras pessoas tentarão primeiro clonar / buscar, use uma URL que eles possam acessar, se possível. Por exemplo, se você usar um URL diferente para enviar do que os outros usuários, use o URL ao qual os outros têm acesso. Você pode substituir este valor localmente git config submodule.DbConnector.url PRIVATE_URLpor seu próprio uso. Quando aplicável, um URL relativo pode ser útil.

A outra listagem na git status saída é a entrada da pasta do projeto. Se você correr git diff sobre isso, você verá algo interessante:

$ git diff --cached DbConnector
diff --git a/DbConnector b/DbConnector
new file mode 160000
index 0000000..c3f01dc
--- /dev/null
+++ b/DbConnector
@@ -0,0 +1 @@
+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc

Embora DbConnector seja um subdiretório em seu diretório de trabalho, o Git o vê como um submódulo e não rastreia seu conteúdo quando você não está nesse diretório. Em vez disso, o Git o vê como um commit particular daquele repositório.

Se você quiser um pouco melhor saída diff, você pode passar a [--submodule] opção para git diff.

$ git diff --cached --submodule
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..71fc376
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "DbConnector"]
+       path = DbConnector
+       url = https://github.com/chaconinc/DbConnector
Submodule DbConnector 0000000...c3f01dc (new submodule)
Quando você se compromete, você vê algo assim:

$ git commit -am 'added DbConnector module'
[master fb9093c] added DbConnector module
 2 files changed, 4 insertions(+)
 create mode 100644 .gitmodules
 create mode 160000 DbConnector

Observe o 160000modo para a DbConnector entrada. Esse é um modo especial no Git que basicamente significa que você está gravando uma confirmação como uma entrada de diretório em vez de um subdiretório ou um arquivo.

Por último, empurre essas alterações:

$ git push origin master


(Clonando um projeto com submódulos)

Aqui vamos clonar um projeto com um submódulo. Quando você clona esse projeto, por padrão, você obtém os diretórios que contêm submódulos, mas nenhum dos arquivos dentro deles ainda:

$ git clone https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
$ cd MainProject
$ ls -la
total 16
drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .
drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..
drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git
-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules
drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector
-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile
drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src
$ cd DbConnector/
$ ls
$

O DbConnectordiretório está lá, mas vazio. Você deve executar dois comandos: [git submodule init[ para inicializar seu arquivo de configuração local e [git submodule update] buscar todos os dados desse projeto e verificar o commit apropriado listado em seu superprojeto:

$ git submodule init
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
$ git submodule update
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'

Agora seu DbConnectorsubdiretório está no estado exato em que estava quando você se comprometeu anteriormente.

Existe outra maneira de fazer isso, que é um pouco mais simples, no entanto. Se você passar --recursivepara o git clonecomando, ele inicializará e atualizará automaticamente cada submódulo no repositório.

$ git clone --recursive https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'

(Trabalhando em um projeto com submódulos)
Agora, temos uma cópia de um projeto com submódulos e colaboramos com nossos colegas no projeto principal e no submódulo.

(Puxando em Upstream Changes)
O modelo mais simples de usar submódulos em um projeto seria se você estivesse simplesmente consumindo um subprojeto e quisesse obter atualizações dele de tempos em tempos, mas na verdade não estivesse modificando nada em seu checkout. Vamos percorrer um exemplo simples lá.

Se você quiser verificar se há novo trabalho em um sub-módulo, você pode ir para o diretório e executar git fetche git mergeo ramo upstream para atualizar o código local.

$ git fetch
From https://github.com/chaconinc/DbConnector
   c3f01dc..d0354fc  master     -> origin/master
$ git merge origin/master
Updating c3f01dc..d0354fc
Fast-forward
 scripts/connect.sh | 1 +
 src/db.c           | 1 +
 2 files changed, 2 insertions(+)

Agora, se você voltar ao projeto principal e executar, git diff --submodulepoderá ver que o submódulo foi atualizado e obter uma lista de confirmações que foram adicionadas a ele. Se você não quiser digitar [--submodule] toda vez que executar [git diff], você pode configurá-lo como o formato padrão, definindo o [diff.submodule] valor de configuração para “log”.

$ git config --global diff.submodule log
$ git diff
Submodule DbConnector c3f01dc..d0354fc:
  > more efficient db routine
  > better connection routine

Se você cometer neste momento, você irá bloquear o submódulo para ter o novo código quando outras pessoas atualizarem.

Há uma maneira mais fácil de fazer isso também, se você preferir não buscar e mesclar manualmente no subdiretório. Se você correr [git submodule update --remote], o Git irá para seus submódulos e buscará e atualizará para você.

$ git submodule update --remote DbConnector
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   3f19983..d0354fc  master     -> origin/master
Submodule path 'DbConnector': checked out 'd0354fc054692d3906c85c3af05ddce39a1c0644'

Esse comando assumirá, por padrão, que você deseja atualizar o checkout para a master ramificação do repositório do submódulo. Você pode, no entanto, definir isso para algo diferente, se quiser. Por exemplo, se você deseja que o submódulo DbConnector acompanhe a ramificação “estável” do repositório, poderá defini-lo em seu [.gitmodules]arquivo (para que todos os outros também o acompanhem) ou apenas em seu [.git/config] arquivo local . Vamos definir no [.gitmodules] arquivo:

$ git config -f .gitmodules submodule.DbConnector.branch stable

$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   27cf5d3..c87d55d  stable -> origin/stable
Submodule path 'DbConnector': checked out 'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'

Se você deixar de fazer [-f .gitmodules] isso, só fará a mudança para você, mas provavelmente faz mais sentido rastrear essa informação com o repositório para que todos façam o mesmo.

Quando corremos [git status] neste ponto, o Git nos mostrará que temos “novos commits” no submódulo.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

  modified:   .gitmodules
  modified:   DbConnector (new commits)

no changes added to commit (use "git add" and/or "git commit -a")

Se você definir a configuração [status.submodulesummary], o Git também mostrará um breve resumo das alterações nos seus submódulos:

$ git config status.submodulesummary 1

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   .gitmodules
	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c3f01dc...c87d55d (4):
  > catch non-null terminated lines
Neste ponto, se você executar git diff, podemos ver ambos que modificamos nosso .gitmodulesarquivo e também que há vários commits que baixamos e estamos prontos para confirmar em nosso projeto de submódulo.

$ git diff
diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
 Submodule DbConnector c3f01dc..c87d55d:
  > catch non-null terminated lines
  > more robust error handling
  > more efficient db routine
  > better connection routine

Isso é muito legal, já que podemos ver o log de commits que estamos prestes a nos comprometer em nosso submódulo. Uma vez confirmada, você pode ver esta informação depois do fato também quando você corre [git log -p].

$ git log -p --submodule
commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Sep 17 16:37:02 2014 +0200

    updating DbConnector for bug fixes

diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
Submodule DbConnector c3f01dc..c87d55d:
  > catch non-null terminated lines
  > more robust error handling
  > more efficient db routine
  > better connection routine

O Git irá, por padrão, tentar atualizar todos os seus submódulos quando você rodar, [git submodule update --remote] então se você tiver muitos deles, você pode querer passar o nome apenas do submódulo que você quer tentar atualizar.

(Trabalhando em um submódulo)
É bem provável que, se você estiver usando submódulos, esteja fazendo isso porque realmente quer trabalhar no código no submódulo ao mesmo tempo em que está trabalhando no código no projeto principal (ou em vários submódulos) . Caso contrário, você provavelmente usaria um sistema de gerenciamento de dependências mais simples (como Maven ou Rubygems).

Então, vamos agora passar por um exemplo de como fazer alterações no submódulo ao mesmo tempo que o projeto principal e cometer e publicar essas mudanças ao mesmo tempo.

Até agora, quando executamos o git submodule update comando para buscar as mudanças dos repositórios do submódulo, o Git obteria as mudanças e atualizaria os arquivos no subdiretório, mas deixaria o sub-repositório no que é chamado de um estado “HEAD separado”. Isso significa que não há um ramo de trabalho local (como "mestre", por exemplo) rastreando as alterações. Sem alterações de rastreamento de ramificação de trabalho, isso significa que, mesmo se você confirmar alterações no submódulo, essas alterações possivelmente serão perdidas na próxima vez que você executar git submodule update. Você precisa fazer algumas etapas extras se desejar que as alterações em um submódulo sejam rastreadas.

Para configurar seu submódulo para ser mais fácil de entrar e invadir, você precisa fazer duas coisas. Você precisa entrar em cada submódulo e verificar um ramo para trabalhar. Então você precisa dizer ao Git o que fazer se você tiver feito alterações e depois git submodule update --remotepuxar o novo trabalho do upstream. As opções são que você pode mesclá-las em seu trabalho local ou tentar redefinir seu trabalho local sobre as novas alterações.

Primeiro de tudo, vamos ao nosso diretório de sub-módulos e confira um branch.

$ git checkout stable
Switched to branch 'stable'
Vamos tentar com a opção "mesclar". Para especificá-lo manualmente, podemos apenas adicionar a --merge opção à nossa update chamada. Aqui veremos que houve uma mudança no servidor para este submódulo e ele será mesclado.

$ git submodule update --remote --merge
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   c87d55d..92c7337  stable     -> origin/stable
Updating c87d55d..92c7337
Fast-forward
 src/main.c | 1 +
 1 file changed, 1 insertion(+)
Submodule path 'DbConnector': merged in '92c7337b30ef9e0893e758dac2459d07362ab5ea'
Se entrarmos no diretório DbConnector, temos as novas alterações já mescladas em nossa stablefilial local . Agora vamos ver o que acontece quando fazemos a nossa própria mudança local para a biblioteca e outra pessoa envia outra mudança ao mesmo tempo.

$ cd DbConnector/
$ vim src/db.c
$ git commit -am 'unicode support'
[stable f906e16] unicode support
 1 file changed, 1 insertion(+)

Agora, se atualizarmos nosso submódulo, podemos ver o que acontece quando fizemos uma mudança local e o upstream também tem uma mudança que precisamos incorporar.

$ git submodule update --remote --rebase
First, rewinding head to replay your work on top of it...
Applying: unicode support
Submodule path 'DbConnector': rebased into '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'

Se você esquecer o --rebase ou --merge, o Git apenas atualizará o submódulo para o que estiver no servidor e redefinirá seu projeto para um estado HEAD separado.

$ git submodule update --remote
Submodule path 'DbConnector': checked out '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'

Se isso acontecer, não se preocupe, você pode simplesmente voltar ao diretório e verificar sua ramificação novamente (que ainda conterá seu trabalho) e mesclar ou rebase origin/stable(ou qualquer ramificação remota desejada) manualmente.

Se você não tiver confirmado suas alterações em seu submódulo e executar uma atualização de submódulo que causaria problemas, o Git buscará as alterações, mas não substituirá o trabalho não salvo no diretório do submódulo.

$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 4 (delta 0)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   5d60ef9..c75e92a  stable     -> origin/stable
error: Your local changes to the following files would be overwritten by checkout:
	scripts/setup.sh
Please, commit your changes or stash them before you can switch branches.
Aborting
Unable to checkout 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'

Se você fez alterações que entram em conflito com algo alterado, o Git avisará quando você executar a atualização.

$ git submodule update --remote --merge
Auto-merging scripts/setup.sh
CONFLICT (content): Merge conflict in scripts/setup.sh
Recorded preimage for 'scripts/setup.sh'
Automatic merge failed; fix conflicts and then commit the result.
Unable to merge 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'

Você pode entrar no diretório do sub-módulo e corrigir o conflito como faria normalmente.


(Publicando Alterações no Submódulo)
Agora temos algumas mudanças em nosso diretório de sub-módulos. Algumas delas foram trazidas do upstream pelas nossas atualizações e outras foram feitas localmente e ainda não estão disponíveis para ninguém, pois ainda não as enviamos.

$ git diff
Submodule DbConnector c87d55d..82d2ad3:
  > Merge from origin/stable
  > updated setup script
  > unicode support
  > remove unnecessary method
  > add new option for conn pooling

Se nos comprometermos no projeto principal e forçá-lo para cima sem empurrar o submódulo, também, outras pessoas que tentarem verificar nossas mudanças estarão em apuros, já que não terão como obter as alterações do submódulo das quais dependem . Essas alterações só existirão em nossa cópia local.

Para garantir que isso não aconteça, você pode pedir ao Git para verificar se todos os seus submódulos foram pressionados corretamente antes de enviar o projeto principal. O [git push] comando aceita o [--recurse-submodules]argumento que pode ser definido como "check" ou "on-demand". A opção "verificar" fará push simplesmente falhar se qualquer uma das alterações consolidadas do submódulo não tiver sido enviada.

$ git push --recurse-submodules=check
The following submodule paths contain changes that can
not be found on any remote:
  DbConnector

Please try

	git push --recurse-submodules=on-demand

or cd to the path and use

	git push

to push them to a remote.

Como você pode ver, isso também nos dá alguns conselhos úteis sobre o que podemos fazer em seguida. A opção simples é entrar em cada submódulo e enviar manualmente para os controles remotos para garantir que estejam disponíveis externamente e, em seguida, tente novamente. Se você quiser que o comportamento de verificação aconteça para todos os pushes, você pode tornar esse comportamento o padrão fazendo [git config push.recurseSubmodules check].

A outra opção é usar o valor "on-demand", que tentará fazer isso por você.

$ git push --recurse-submodules=on-demand
Pushing submodule 'DbConnector'
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 3), reused 0 (delta 0)
To https://github.com/chaconinc/DbConnector
   c75e92a..82d2ad3  stable -> stable
Counting objects: 2, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
To https://github.com/chaconinc/MainProject
   3d6d338..9a377d1  master -> master

Como você pode ver lá, Git entrou no módulo DbConnector e o empurrou antes de empurrar o projeto principal. Se o envio desse submódulo falhar por algum motivo, o envio principal do projeto também falhará. Você pode tornar esse comportamento o padrão fazendo [git config push.recurseSubmodules on-demand].

(Mesclando Mudanças no Submódulo)
Se você alterar uma referência de submódulo ao mesmo tempo que outra pessoa, poderá encontrar alguns problemas. Ou seja, se os históricos de submódulos divergiram e estão comprometidos com ramificações divergentes em um superprojeto, pode ser necessário um pouco de trabalho para você corrigir.

Se um dos commits é um ancestral direto do outro (uma fusão rápida), então o Git irá simplesmente escolher o último para a fusão, então isso funciona bem.

O Git não tentará nem mesmo uma junção trivial para você. Se o submódulo se comprometer e precisar ser mesclado, você obterá algo parecido com isto:

$ git pull
remote: Counting objects: 2, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 2 (delta 1), reused 2 (delta 1)
Unpacking objects: 100% (2/2), done.
From https://github.com/chaconinc/MainProject
   9a377d1..eb974f8  master     -> origin/master
Fetching submodule DbConnector
warning: Failed to merge submodule DbConnector (merge following commits not found)
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.

Então, basicamente, o que aconteceu aqui é que o Git descobriu que os dois ramos registram pontos na história do submódulo que são divergentes e precisam ser mesclados. Ele explica isso como “mesclar após os commits não encontrados”, o que é confuso, mas vamos explicar por que isso acontece daqui a pouco.

Para resolver o problema, você precisa descobrir em que estado o submódulo deve estar. Estranhamente, o Git realmente não lhe dá muitas informações para ajudar aqui, nem mesmo os SHA-1s dos commits de ambos os lados da história. Felizmente, é simples descobrir. Se você executar, git diff poderá obter os SHA-1s dos commits registrados em ambos os branches que você estava tentando mesclar.

$ git diff
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector

Então, neste caso, eb41d76é a confirmação do nosso sub-módulo que nós tivemos e c771610é a cometer esse montante tinha. Se entrarmos no nosso diretório de sub-módulos, ele já deve estar ligado, eb41d76já que a mesclagem não o teria tocado. Se por alguma razão não for, você pode simplesmente criar e fazer o checkout de um branch apontando para ele.

O que é importante é o SHA-1 do commit do outro lado. Isso é o que você terá que mesclar e resolver. Você pode apenas tentar a mesclagem com o SHA-1 diretamente, ou você pode criar um ramo para ele e então tentar mesclar isso. Nós sugeriríamos o último, mesmo que apenas para fazer uma mensagem de consolidação de mesclagem mais agradável.

Então, entraremos em nosso diretório de sub-módulos, criaremos uma ramificação baseada naquele segundo SHA-1 git diffe manualmente mesclaremos.

$ cd DbConnector

$ git rev-parse HEAD
eb41d764bccf88be77aced643c13a7fa86714135

$ git branch try-merge c771610
(DbConnector) $ git merge try-merge
Auto-merging src/main.c
CONFLICT (content): Merge conflict in src/main.c
Recorded preimage for 'src/main.c'
Automatic merge failed; fix conflicts and then commit the result.
Nós temos um conflito real de mesclagem aqui, então se resolvermos isso e confirmarmos, podemos simplesmente atualizar o projeto principal com o resultado.

$ vim src/main.c (1)
$ git add src/main.c
$ git commit -am 'merged our changes'
Recorded resolution for 'src/main.c'.
[master 9fd905e] merged our changes

$ cd .. (2)
$ git diff (3)
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
@@@ -1,1 -1,1 +1,1 @@@
- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135
 -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d
++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a
$ git add DbConnector (4)

$ git commit -m "Merge Tom's Changes" (5)
[master 10d2c60] Merge Tom's Changes


1. Primeiro resolvemos o conflito
2. Então voltamos para o diretório principal do projeto
3. Podemos verificar o SHA-1s novamente
4. Resolver a entrada do submódulo conflitante
5. Cometer a nossa fusão

Pode ser um pouco confuso, mas não é muito difícil.

Curiosamente, há outro caso que o Git manipula. Se uma consolidação de mesclagem existir no diretório do submódulo que contém ambas as confirmações em seu histórico, o Git sugerirá a você como uma possível solução. Ele vê que em algum ponto no projeto do submódulo, alguém mesclou ramificações contendo esses dois commits, então talvez você queira esse.

É por isso que a mensagem de erro de antes era “mesclar após os commits não encontrados”, porque não podia fazer isso . É confuso porque quem esperaria que tentasse fazer isso?

Se encontrar um único commit de mesclagem aceitável, você verá algo assim:

$ git merge origin/master
warning: Failed to merge submodule DbConnector (not fast-forward)
Found a possible merge resolution for the submodule:
 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: > merged our changes
If this is correct simply add it to the index for example
by using:

  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a "DbConnector"

which will accept this suggestion.
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.

O que está sugerindo que você faça é atualizar o índice como você executou git add, o que limpa o conflito e, em seguida, confirma. Você provavelmente não deveria fazer isso. Você pode facilmente entrar no diretório do submódulo, ver qual é a diferença, avançar rapidamente para este commit, testá-lo corretamente e, em seguida, confirmá-lo.

$ cd DbConnector/
$ git merge 9fd905e
Updating eb41d76..9fd905e
Fast-forward

$ cd ..
$ git add DbConnector
$ git commit -am 'Fast forwarded to a common submodule child'
Isso realiza a mesma coisa, mas pelo menos dessa maneira você pode verificar se funciona e se você tem o código no diretório do submódulo quando terminar.

(Dicas Submodulares)
Existem algumas coisas que você pode fazer para tornar o trabalho com submódulos um pouco mais fácil.

(Submódulo Foreach)
Existe um [foreach] comando submódulo para executar algum comando arbitrário em cada submódulo. Isso pode ser muito útil se você tiver vários submódulos no mesmo projeto.

Por exemplo, digamos que queremos iniciar um novo recurso ou fazer um bugfix e temos trabalhos em vários submódulos. Podemos facilmente esconder todo o trabalho em todos os nossos submódulos.

$ git submodule foreach 'git stash'
Entering 'CryptoLibrary'
No local changes to save
Entering 'DbConnector'
Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable
HEAD is now at 82d2ad3 Merge from origin/stable

Então podemos criar um novo ramo e mudar para ele em todos os nossos submódulos.

$ git submodule foreach 'git checkout -b featureA'
Entering 'CryptoLibrary'
Switched to a new branch 'featureA'
Entering 'DbConnector'
Switched to a new branch 'featureA'

Você entendeu a ideia. Uma coisa realmente útil que você pode fazer é produzir um bom e unificado diff do que foi alterado no seu projeto principal e em todos os seus subprojetos também.

$ git diff; git submodule foreach 'git diff'
Submodule DbConnector contains modified content
diff --git a/src/main.c b/src/main.c
index 210f1ae..1f0acdc 100644
--- a/src/main.c
+++ b/src/main.c
@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)

      commit_pager_choice();

+     url = url_decode(url_orig);
+
      /* build alias_argv */
      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));
      alias_argv[0] = alias_string + 1;
Entering 'DbConnector'
diff --git a/src/db.c b/src/db.c
index 1aaefb6..5297645 100644
--- a/src/db.c
+++ b/src/db.c
@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)
        return url_decode_internal(&url, len, NULL, &out, 0);
 }

+char *url_decode(const char *url)
+{
+       return url_decode_mem(url, strlen(url));
+}
+
 char *url_decode_parameter_name(const char **query)
 {
        struct strbuf out = STRBUF_INIT;

Aqui podemos ver que estamos definindo uma função em um submódulo e chamando-a no projeto principal. Este é obviamente um exemplo simplificado, mas esperamos que ele dê uma idéia de como isso pode ser útil.

(Aliases Úteis)
Você pode querer configurar alguns aliases para alguns desses comandos, pois eles podem ser bastante longos e você não pode definir opções de configuração para a maioria deles para torná-los padrões. Cobrimos a configuração de aliases do Git no Git Aliases , mas aqui está um exemplo do que você pode querer configurar se planeja trabalhar muito com submódulos no Git.

$ git config alias.sdiff '!'"git diff && git submodule foreach 'git diff'"
$ git config alias.spush 'push --recurse-submodules=on-demand'
$ git config alias.supdate 'submodule update --remote --merge'

Dessa forma, você pode simplesmente executar [git supdate] quando quiser atualizar seus submódulos ou [git spush]pressionar a verificação de dependência do submódulo.

(Problemas com submódulos)
Usando submodules não é sem soluços, no entanto.

Por exemplo, alternar ramos com submódulos neles também pode ser complicado. Se você criar uma nova ramificação, incluir um submódulo nela e, em seguida, alternar de volta para uma ramificação sem esse submódulo, ainda terá o diretório submódulo como um diretório não controlado:

$ git checkout -b add-crypto
Switched to a new branch 'add-crypto'

$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
...

$ git commit -am 'adding crypto library'
[add-crypto 4445836] adding crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

$ git checkout master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	CryptoLibrary/

nothing added to commit but untracked files present (use "git add" to track)

Remover o diretório não é difícil, mas pode ser um pouco confuso ter isso lá. Se você removê-lo e, em seguida, voltar para o ramo que tem esse submódulo, você precisará executar [submodule update --init] para preenchê-lo novamente.

$ git clean -ffdx
Removing CryptoLibrary/

$ git checkout add-crypto
Switched to branch 'add-crypto'

$ ls CryptoLibrary/

$ git submodule update --init
Submodule path 'CryptoLibrary': checked out 'b8dda6aa182ea4464f3f3264b11e0268545172af'

$ ls CryptoLibrary/
Makefile	includes	scripts		src

Mais uma vez, não é realmente muito difícil, mas pode ser um pouco confuso.

A outra ressalva principal que muitas pessoas enfrentam envolve a mudança de subdiretórios para submódulos. Se você estiver rastreando arquivos em seu projeto e quiser movê-los para um submódulo, deve ter cuidado ou o Git ficará com raiva de você. Suponha que você tenha arquivos em um subdiretório do seu projeto e deseje alterná-lo para um submódulo. Se você deletar o subdiretório e rodar [submodule add], o Git grita com você:

$ rm -Rf CryptoLibrary/
$ git submodule add https://github.com/chaconinc/CryptoLibrary
'CryptoLibrary' already exists in the index
Você tem que desassociar o CryptoLibrarydiretório primeiro. Então você pode adicionar o submódulo:

$ git rm -r CryptoLibrary
$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.

Agora suponha que você fez isso em um ramo. Se você tentar voltar para uma ramificação em que esses arquivos ainda estão na árvore real, em vez de em um submódulo, você recebe este erro:

$ git checkout master
error: The following untracked working tree files would be overwritten by checkout:
  CryptoLibrary/Makefile
  CryptoLibrary/includes/crypto.h
  ...
Please move or remove them before you can switch branches.
Aborting

Você pode forçá-lo a alternar [checkout -f], mas tenha cuidado para não ter alterações não salvas, pois elas podem ser sobrescritas com esse comando.

$ git checkout -f master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'

Então, quando você voltar, você obtém um [CryptoLibrary] diretório vazio por algum motivo e [git submodule update]pode não consertá-lo também. Você pode precisar entrar em seu diretório de sub-módulos e executar um [git checkout .] para recuperar todos os seus arquivos. Você pode executar isso em um [submodule foreach] script para executá-lo para vários submódulos.

É importante notar que os sub-módulos atualmente mantêm todos os seus dados no .git diretório do projeto , portanto, ao contrário de muitas versões antigas do Git, a destruição de um diretório de sub-módulos não perderá nenhum commit ou ramificação que você tenha.

Com essas ferramentas, os submódulos podem ser um método bastante simples e eficaz para o desenvolvimento de vários projetos relacionados, mas ainda separados, simultaneamente.


7.12 [[ Git Tools - Empacotando ]]

*Empacotamento
Embora tenhamos coberto as maneiras comuns de transferir dados do Git através de uma rede (HTTP, SSH, etc), existe na verdade mais uma maneira de fazê-lo que não é comumente usada, mas na verdade pode ser bastante útil.

O Git é capaz de “empacotar” seus dados em um único arquivo. Isso pode ser útil em vários cenários. Talvez sua rede esteja inoperante e você queira enviar alterações para seus colegas de trabalho. Talvez você esteja trabalhando em algum lugar externo e não tenha acesso à rede local por motivos de segurança. Talvez sua placa wireless / ethernet tenha acabado de funcionar. Talvez você não tenha acesso a um servidor compartilhado no momento, deseja enviar atualizações por e-mail a alguém e não deseja transferir 40 commits via format-patch.

É aqui que o [git bundle] comando pode ser útil. O bundle comando irá empacotar tudo o que normalmente seria enviado através do fio com um [git push] comando para um arquivo binário que você pode enviar por e-mail para alguém ou colocar em uma unidade flash, em seguida, desmembrar em outro repositório.

Vamos ver um exemplo simples. Digamos que você tenha um repositório com dois commits:

$ git log
commit 9a466c572fe88b195efd356c3f2bbeccdb504102
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Mar 10 07:34:10 2010 -0800

    second commit

commit b1ec3248f39900d2a406049d762aa68e9641be25
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Mar 10 07:34:01 2010 -0800

    first commit

Se você quiser enviar esse repositório para alguém e não tiver acesso a um repositório para o qual enviar ou simplesmente não quiser configurá-lo, será possível empacotá-lo [git bundle create].

$ git bundle create repo.bundle HEAD master
Counting objects: 6, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (6/6), 441 bytes, done.
Total 6 (delta 0), reused 0 (delta 0)

Agora você tem um arquivo chamado repo.bundle que possui todos os dados necessários para recriar o master ramo do repositório . Com o bundle comando, você precisa listar cada referência ou intervalo específico de commits que você deseja incluir. Se você pretende que isso seja clonado em outro lugar, você deve adicionar o HEAD como referência, assim como fizemos aqui.

Você pode enviar esse repo.bundle arquivo por e-mail para outra pessoa, ou colocá-lo em uma unidade USB e passá-lo.

Por outro lado, digamos que você tenha enviado este repo.bundle arquivo e queira trabalhar no projeto. Você pode clonar o arquivo binário em um diretório, da mesma forma que faria em um URL.

$ git clone repo.bundle repo
Cloning into 'repo'...
...
$ cd repo
$ git log --oneline
9a466c5 second commit
b1ec324 first commit

Se você não incluir o HEAD nas referências, você também deve especificar -b masterou o ramo que está incluído, porque, do contrário, ele não saberá qual ramificação verificar.

Agora digamos que você faça três commits nele e queira enviar os novos commits de volta através de um pacote em um pendrive ou e-mail.

$ git log --oneline
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo
9a466c5 second commit
b1ec324 first commit

Primeiro, precisamos determinar o intervalo de commits que queremos incluir no pacote. Ao contrário dos protocolos de rede que calculam o conjunto mínimo de dados a serem transferidos pela rede para nós, teremos que descobrir isso manualmente. Agora, você poderia fazer a mesma coisa e agrupar todo o repositório, o que funcionará, mas é melhor apenas agrupar a diferença - apenas os três commits que acabamos de fazer localmente.

Para fazer isso, você terá que calcular a diferença. Conforme descrevemos em Commit Ranges , você pode especificar um intervalo de commits de várias maneiras. Para obter os três commits que temos em nossa ramificação principal que não estavam na ramificação originalmente clonada, podemos usar algo como [origin/master..master] ou [master ^origin/master]. Você pode testar isso com o log comando.

$ git log --oneline master ^origin/master
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo

Então, agora que temos a lista de commits que queremos incluir no pacote, vamos agrupá-los. Fazemos isso com o git bundle create comando, dando a ele um nome de arquivo que queremos que nosso pacote seja e o intervalo de commits que queremos incluir nele.

$ git bundle create commits.bundle master ^9a466c5
Counting objects: 11, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (9/9), 775 bytes, done.
Total 9 (delta 0), reused 0 (delta 0)

Agora temos um commits.bundle arquivo em nosso diretório. Se pegarmos isso e enviarmos para o nosso parceiro, ela poderá importá-lo para o repositório original, mesmo que mais trabalhos tenham sido feitos nesse meio tempo.

Quando ela recebe o pacote, ela pode inspecioná-lo para ver o que ele contém antes de importá-lo em seu repositório. O primeiro comando é o [bundle verify] comando que fará com que o arquivo seja realmente um pacote Git válido e que você tenha todos os ancestrais necessários para reconstituí-lo corretamente.

$ git bundle verify ../commits.bundle
The bundle contains 1 ref
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master
The bundle requires these 1 ref
9a466c572fe88b195efd356c3f2bbeccdb504102 second commit
../commits.bundle is okay

Se o bundler tivesse criado um pacote de apenas os últimos dois commits que eles haviam feito, ao invés de todos os três, o repositório original não seria capaz de importá-lo, já que está faltando um histórico de requisitos. O verify comando teria sido assim:

$ git bundle verify ../commits-bad.bundle
error: Repository lacks these prerequisite commits:
error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 third commit - second repo

No entanto, nosso primeiro pacote é válido, portanto, podemos buscar em commits dele. Se você quiser ver quais ramificações estão no pacote que podem ser importadas, há também um comando para listar as cabeças:

$ git bundle list-heads ../commits.bundle
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master

O [verifysub] comando também lhe dirá as cabeças. O ponto é ver o que pode ser puxado, então você pode usar os comandos fetch ou pull para importar commits deste bundle. Aqui, vamos buscar a ramificação principal do pacote para uma ramificação chamada other-master em nosso repositório:

$ git fetch ../commits.bundle master:other-master
From ../commits.bundle
 * [new branch]      master     -> other-master

Agora, podemos ver que temos os commits importados na ramificação de outros mestres , bem como quaisquer commits que tenhamos feito nesse meio tempo em nossa própria ramificação principal .

$ git log --oneline --decorate --graph --all
* 8255d41 (HEAD, master) third commit - first repo
| * 71b84da (other-master) last commit - second repo
| * c99cf5b fourth commit - second repo
| * 7011d3d third commit - second repo
|/
* 9a466c5 second commit
* b1ec324 first commit

Portanto, git bundle pode ser realmente útil para compartilhar ou fazer operações do tipo de rede quando você não tem a rede adequada ou o repositório compartilhado para fazer isso.


7.13 [[ Git Tools - Substituir ]]

*Substituir
Os objetos do Git são imutáveis, mas fornecem uma maneira interessante de pretender substituir objetos em seu banco de dados por outros objetos.

O replace comando permite que você especifique um objeto no Git e diga "toda vez que vir isso, finja que é outra coisa". Isso é mais comumente útil para substituir um commit no seu histórico por outro.

Por exemplo, digamos que você tenha um histórico de código enorme e queira dividir seu repositório em um breve histórico para novos desenvolvedores e um histórico muito maior e maior para pessoas interessadas em mineração de dados. Você pode enxertar um histórico no outro, substituindo o primeiro commit na nova linha com o mais recente commit no mais antigo. Isso é bom porque significa que você não precisa reescrever cada commit no novo histórico, como você normalmente teria que fazer para juntá-los (porque o parentesco afeta os SHA-1s).

Vamos tentar isso. Vamos pegar um repositório existente, dividi-lo em dois repositórios, um recente e outro histórico, e então veremos como podemos recombinar os mesmos sem modificar os valores dos repositórios recentes SHA-1 via replace.

Vamos usar um repositório simples com cinco commits simples:

$ git log --oneline
ef989d8 fifth commit
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit

Queremos dividir isso em duas linhas da história. Uma linha vai de cometer um para cometer quatro - esse será o histórico. A segunda linha será apenas comete quatro e cinco - essa será a história recente.


                        
                            
                                [figure - 164 - replace1]



Bem, criar a história histórica é fácil, podemos apenas colocar uma ramificação no histórico e, em seguida, empurrar essa ramificação para a ramificação principal de um novo repositório remoto.

$ git branch history c6e1e95
$ git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit


                                     [figure - 165 - replace 2]


Agora podemos enviar o novo [history] ramo para o [master] ramo do nosso novo repositório:

$ git remote add project-history https://github.com/schacon/project-history
$ git push project-history history:master
Counting objects: 12, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (12/12), 907 bytes, done.
Total 12 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (12/12), done.
To git@github.com:schacon/project-history.git
 * [new branch]      history -> master

OK, então nossa história é publicada. Agora a parte mais difícil é truncar a nossa história recente, então é menor. Nós precisamos de uma sobreposição para que possamos substituir um commit em um com um commit equivalente no outro, então vamos truncar isto para apenas commits de quatro e cinco (então comete quatro sobreposições).

$ git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
É útil, neste caso, criar um commit de base que tenha instruções sobre como expandir o histórico, para que outros desenvolvedores saibam o que fazer se acertarem o primeiro commit no histórico truncado e precisarem de mais. Então, o que nós vamos fazer é criar um objeto de commit inicial como nosso ponto de base com instruções, então rebase os commits restantes (quatro e cinco) em cima dele.

Para fazer isso, precisamos escolher um ponto para dividir em, que para nós é o terceiro commit, que é 9c68fdc em linguagem SHA. Então, nosso commit base será baseado naquela árvore. Nós podemos criar nossa base commit usando o [commit-tree] comando, que apenas pega uma árvore e nos dará um novo objeto de commit sem pais SHA-1 de volta.

$ echo 'get history from blah blah blah' | git commit-tree 9c68fdc^{tree}
622e88e9cbfbacfb75b5279245b9fb38dfea10cf


|Nota
O [commit-tree] comando é um de um conjunto de comandos que são comumente chamados de comandos de encanamento . Estes são comandos que geralmente não são usados ​​diretamente, mas são usados ​​por outros comandos do Git para fazer trabalhos menores. Em ocasiões em que estamos fazendo coisas mais estranhas como essas, elas nos permitem fazer coisas realmente de baixo nível, mas não são destinadas ao uso diário. Você pode ler mais sobre os comandos de encanamento em encanamento e porcelana.


                                        [figure - 166 - repllace 3]



OK, agora que temos um commit de base, podemos rebase o resto de nossa história em cima disso com [git rebase --onto[. O [--onto] argumento será o SHA-1 do qual acabamos de voltar commit-tree e o ponto de rebase será o terceiro commit (o pai do primeiro commit que queremos manter 9c68fdc):

$ git rebase --onto 622e88 9c68fdc
First, rewinding head to replay your work on top of it...
Applying: fourth commit
Applying: fifth commit

                                        [figure - 167 - repllace 4]



OK, então agora nós reescrevemos nossa história recente em cima de um commit de base descartável que agora tem instruções sobre como reconstituir a história inteira, se quiséssemos. Podemos empurrar esse novo histórico para um novo projeto e, agora, quando as pessoas clonam esse repositório, eles verão apenas os dois commits mais recentes e, em seguida, um commit de base com instruções.

Vamos agora trocar as funções para alguém clonando o projeto pela primeira vez, que quer a história inteira. Para obter os dados do histórico após clonar esse repositório truncado, seria necessário incluir um segundo controle remoto para o repositório histórico e buscar:

$ git clone https://github.com/schacon/project
$ cd project

$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

$ git remote add project-history https://github.com/schacon/project-history
$ git fetch project-history
From https://github.com/schacon/project-history
 * [new branch]      master     -> project-history/master


Agora o colaborador teria seus commits recentes no master branch e os commits históricos no project-history/master branch.

$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

$ git log --oneline project-history/master
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit

Para combiná-los, você pode simplesmente chamar [git replace] com o commit que deseja substituir e depois o commit com o qual deseja substituí-lo. Então, queremos substituir o "quarto" commit no branch master pelo "fourth" commit no project-history/masterbranch:

$ git replace 81a708d c6e1e95

Agora, se você observar o histórico da master ramificação, parece ter esta aparência:

$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit

Legal certo? Sem ter que mudar todos os Sha-1s a montante, fomos capazes de substituir um commit na nossa história com um totalmente diferente cometer e todas as ferramentas normais ( bisect, blame, etc) irá funcionar como seria de esperar que eles.



                                        [figure - 168 -  replace 5]



Curiosamente, ele ainda é mostrado 81a708dcomo o SHA-1, embora esteja realmente usando os c6e1e95dados de confirmação com os quais o substituímos. Mesmo se você executar um comando como [cat-file], ele mostrará os dados substituídos:

$ git cat-file -p 81a708d
tree 7bc544cf438903b65ca9104a1e30345eee6c083d
parent 9c68fdceee073230f19ebb8b5e7fc71b479c0252
author Scott Chacon <schacon@gmail.com> 1268712581 -0700
committer Scott Chacon <schacon@gmail.com> 1268712581 -0700

fourth commit

Lembre-se de que o pai real de 81a708dfoi o nosso commit de placeholder ( 622e88e), e não o 9c68fdce que está escrito aqui.

Outra coisa interessante é que esses dados são mantidos em nossas referências:

$ git for-each-ref
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/heads/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/remotes/history/master
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/HEAD
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/replace/81a708dd0e167a3f691541c7a6463343bc457040

Isso significa que é fácil compartilhar nossa substituição com outras pessoas, porque podemos enviar isso para o nosso servidor e outras pessoas podem baixá-lo facilmente. Isso não é útil no cenário de enxerto de história que vimos aqui (já que todo mundo estaria baixando os dois históricos de qualquer forma, então por que separá-los?), Mas pode ser útil em outras circunstâncias.


7.14 [[ Git Tools - Armazenamento de Credenciais ]]

*Armazenamento de credenciais
Se você usa o transporte SSH para conectar-se a controles remotos, é possível ter uma chave sem uma frase secreta, que permite transferir dados com segurança sem digitar seu nome de usuário e senha. No entanto, isso não é possível com os protocolos HTTP - cada conexão precisa de um nome de usuário e senha. Isso fica ainda mais difícil para sistemas com autenticação de dois fatores, onde o token usado por uma senha é gerado aleatoriamente e impronunciável.

Felizmente, o Git possui um sistema de credenciais que pode ajudar nisso. O Git tem algumas opções fornecidas na caixa:

. O padrão é não armazenar em cache. Cada conexão solicitará seu nome de usuário e senha.

. O modo "cache" mantém as credenciais na memória por um determinado período de tempo. Nenhuma das senhas é armazenada no disco e elas são removidas do cache após 15 minutos.

. O modo “armazenar” salva as credenciais em um arquivo de texto simples no disco e elas nunca expiram. Isso significa que, até você alterar sua senha para o host Git, você nunca precisará digitar suas credenciais novamente. A desvantagem dessa abordagem é que suas senhas são armazenadas em texto não criptografado em um arquivo simples em seu diretório inicial.

. Se você estiver usando um Mac, o Git vem com um modo “osxkeychain”, que armazena em cache credenciais nas chaves seguras que estão anexadas à sua conta do sistema. Esse método armazena as credenciais no disco e elas nunca expiram, mas são criptografadas com o mesmo sistema que armazena certificados HTTPS e preenchimentos automáticos do Safari.

. Se você estiver usando o Windows, poderá instalar um assistente chamado "wincred". Isso é semelhante ao auxiliar "osxkeychain" descrito acima, mas usa o Windows Credential Store para controlar informações confidenciais.

Você pode escolher um desses métodos definindo um valor de configuração do Git:

$ git config --global credential.helper cache

Alguns desses ajudantes têm opções. O ajudante "store" pode receber um [--file <path>] argumento, que customiza onde o arquivo de texto simples é salvo (o padrão é ~/.git-credentials). O ajudante "cache" aceita a [--timeout <seconds>] opção, que altera a quantidade de tempo que seu daemon é mantido em execução (o padrão é "900" ou 15 minutos). Aqui está um exemplo de como você configuraria o ajudante "store" com um nome de arquivo personalizado:

$ git config --global credential.helper 'store --file ~/.my-credentials'

O Git permite até que você configure vários helpers. Ao procurar por credenciais para um determinado host, o Git as consultará em ordem e parará após a primeira resposta ser fornecida. Ao salvar as credenciais, o Git enviará o nome de usuário e a senha para todos os ajudantes da lista e eles poderão escolher o que fazer com eles. Veja como .gitconfig ficaria se você tivesse um arquivo de credenciais em um pen drive, mas quisesse usar o cache na memória para economizar alguma digitação se a unidade não estivesse conectada:

[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000


(Sob o capô)
Como tudo isso funciona? O comando raiz do Git para o sistema de credencial-auxiliar é [git credential], o que leva um comando como um argumento e, em seguida, mais entrada através de stdin.

Isso pode ser mais fácil de entender com um exemplo. Digamos que um auxiliar de credencial tenha sido configurado e o assistente tenha credenciais armazenadas [mygithost]. Aqui está uma sessão que usa o comando “fill”, que é invocado quando o Git está tentando encontrar credenciais para um host:

$ git credential fill (1)
protocol=https (2)
host=mygithost
(3)
protocol=https (4)
host=mygithost
username=bob
password=s3cre7
$ git credential fill (5)
protocol=https
host=unknownhost

Username for 'https://unknownhost': bob
Password for 'https://bob@unknownhost':
protocol=https
host=unknownhost
username=bob
password=s3cre7

1. Esta é a linha de comando que inicia a interação.
2. Git-credential está aguardando entrada no stdin. Nós fornecemos as coisas que conhecemos: o protocolo e hostname.
3. Uma linha em branco indica que a entrada está completa e o sistema de credenciais deve responder com o que sabe.
4. Git-credential, em seguida, assume e escreve para stdout com os bits de informação que encontrou.
5. Se as credenciais não forem encontradas, o Git solicitará ao usuário o nome de usuário e a senha e os fornecerá de volta ao stdout de chamada (aqui eles estão conectados ao mesmo console).

O sistema de credenciais está realmente invocando um programa separado do próprio Git; qual e como depende do [credential.helper] valor de configuração. Existem várias formas possíveis:


------------------------------------------------------------------------------------
Valor de Configuração	                     Comportamento
------------------------------------------------------------------------------------

foo                                         Corre git-credential-foo

foo -a --opt=bcd                            Corre git-credential-foo -a --opt=bcd

/absolute/path/foo -xyz                     Corre /absolute/path/foo -xyz

!f() { echo "password=s3cre7"; }; f         Código após !avaliado em shell

--------------------------------------------------------------------------------------


Portanto, os ajudantes descritos acima são realmente denominados[git-credential-cache], [git-credential-store] e assim por diante, e podemos configurá-los para obter argumentos de linha de comando. A forma geral para isso é "git-credential-foo [args] <ação>". O protocolo stdin / stdout é o mesmo que git-credential, mas eles usam um conjunto de ações um pouco diferente:

. [get] é um pedido para um par nome de usuário / senha.

. [store] é uma solicitação para salvar um conjunto de credenciais na memória desse auxiliar.

. [erase] purgar as credenciais para as propriedades dadas da memória desse auxiliar.

Para as ações [store] e [erase], nenhuma resposta é necessária (o Git a ignora de qualquer maneira). Para a [get] ação, no entanto, Git está muito interessado no que o ajudante tem a dizer. Se o ajudante não souber de nada útil, ele pode simplesmente sair sem saída, mas, se souber, deve aumentar as informações fornecidas com as informações armazenadas. A saída é tratada como uma série de instruções de atribuição; qualquer coisa fornecida substituirá o que o Git já sabe.

Aqui está o mesmo exemplo acima, mas ignorando a credencial do git e indo direto para o git-credential-store:

$ git credential-store --file ~/git.store store (1)
protocol=https
host=mygithost
username=bob
password=s3cre7
$ git credential-store --file ~/git.store get (2)
protocol=https
host=mygithost

username=bob (3)
password=s3cre7


1. Aqui nós dizemos [git-credential-store]para salvar algumas credenciais: o nome de usuário "bob" e a senha "s3cre7" devem ser usados ​​quando https://mygithostfor acessado.

2. Agora vamos recuperar essas credenciais. Fornecemos as partes da conexão que já conhecemos ( https://mygithost) e uma linha vazia.

3. git-credential-store responde com o nome de usuário e senha que armazenamos acima.

Aqui está o que o [~/git.store] arquivo se parece:

https://bob:s3cre7@mygithost

É apenas uma série de linhas, cada uma contendo um URL com credenciais. O [osxkeychain] e [wincred] ajudantes usar o formato nativo de suas lojas de apoio, enquanto cacheusa seu próprio formato in-memory (que nenhum outro processo pode ler).

(Um cache de credencial personalizada)
Dado que [git-credential-store] e os amigos são programas separados do Git, não é muito difícil perceber que qualquer programa pode ser um auxiliar de credencial do Git. Os ajudantes fornecidos pelo Git abrangem muitos casos de uso comuns, mas não todos. Por exemplo, digamos que sua equipe tenha algumas credenciais compartilhadas com toda a equipe, talvez para implantação. Eles são armazenados em um diretório compartilhado, mas você não deseja copiá-los para seu próprio armazenamento de credenciais porque eles são alterados com frequência. Nenhum dos ajudantes existentes cobre este caso; vamos ver o que seria necessário para escrevermos o nosso. Existem vários recursos importantes que este programa precisa ter:


1. A única ação que precisamos prestar atenção é get; storee erasesão operações de gravação, então vamos sair de maneira limpa quando forem recebidas.

2. O formato de arquivo do arquivo de credencial compartilhada é o mesmo usado por [git-credential-store].

3. A localização desse arquivo é bastante padrão, mas devemos permitir que o usuário passe um caminho personalizado apenas no caso.


Mais uma vez, vamos escrever esta extensão em Ruby, mas qualquer linguagem funcionará desde que o Git possa executar o produto final. Aqui está o código-fonte completo do nosso novo auxiliar de credencial:

#!/usr/bin/env ruby

require 'optparse'

path = File.expand_path '~/.git-credentials' (1)
OptionParser.new do |opts|
    opts.banner = 'USAGE: git-credential-read-only [options] <action>'
    opts.on('-f', '--file PATH', 'Specify path for backing store') do |argpath|
        path = File.expand_path argpath
    end
end.parse!

exit(0) unless ARGV[0].downcase == 'get' (2)
exit(0) unless File.exists? path

known = {} (3)
while line = STDIN.gets
    break if line.strip == ''
    k,v = line.strip.split '=', 2
    known[k] = v
end

File.readlines(path).each do |fileline| (4)
    prot,user,pass,host = fileline.scan(/^(.*?):\/\/(.*?):(.*?)@(.*)$/).first
    if prot == known['protocol'] and host == known['host'] and user == known['username'] then
        puts "protocol=#{prot}"
        puts "host=#{host}"
        puts "username=#{user}"
        puts "password=#{pass}"
        exit(0)
    end
end


Aqui nós analisamos as opções de linha de comando, permitindo que o usuário especifique o arquivo de entrada. O padrão é [~/.git-credentials].

1. Este programa responde apenas se a ação [get] e o arquivo de armazenamento de apoio existirem.

2. Este laço lê de stdin até que a primeira linha em branco seja alcançada. As entradas são armazenadas no [known]hash para referência futura.

3. Esse loop lê o conteúdo do arquivo de armazenamento, procurando por correspondências. Se o protocolo e o host knowncoincidirem com esta linha, o programa imprime os resultados para stdout e sai.

4. Vamos salvar nosso ajudante como [git-credential-read-only], colocá-lo em algum lugar no nosso PATHe marcá-lo como executável. Aqui está uma sessão interativa:

$ git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost

protocol=https
host=mygithost
username=bob
password=s3cre7

Como seu nome começa com "git-", podemos usar a sintaxe simples para o valor de configuração:

$ git config --global credential.helper 'read-only --file /mnt/shared/creds'

Como você pode ver, ampliar esse sistema é bastante simples e pode resolver alguns problemas comuns para você e sua equipe.

7.15 [[ Ferramentas do Git - Resumo ]]

*Resumo
Você viu várias ferramentas avançadas que permitem manipular seus commits e áreas de teste com mais precisão. Quando você perceber problemas, você deve ser capaz de descobrir com facilidade qual commit os apresentou, quando e por quem. Se você quiser usar subprojetos em seu projeto, aprendeu a acomodar essas necessidades. Neste ponto, você deve ser capaz de fazer a maioria das coisas no Git que você precisa no dia a dia da linha de comando e se sentir à vontade para fazê-lo.